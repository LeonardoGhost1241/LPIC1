================================================
Determinar y configurar los ajustes del hardware 
================================================

lspci - muestra los dispositivos conectados al bus PCI (Peripheral Component Interconnect), componentes conectados a la placa base, controlador de disco o una tarjeta de expansion
*lOs numeros hexadecimales al principio de cada linea son las direcciones unicas del dispositivo PCI correspondiente
	-s especificar la direccion 
	-v modo verbose 
		ejemplo: lspci -s 04:02.0 -v 
	-k (disponible en versiones mas resientes) verifica que el modulo del nucleo del SO esta en uso para el dispositivo

*Si el dispositivo no esta operativo, puede que se requiera un componente de software para controlar el dispositivo correspondiente. Este componente se denomina, "Modulo de kernel",
puede ser parte del nucleo o agregarse por separado por otras fuentes

-Los modulos del nucleo de linux rlacionados con hardware se denominan controladores

lsusb - enumera dispositivos conectados mediante USB
	-v modo verbose 
	-d selecciona un dispositivo mediante su ID ejem:1d6b:0002
		ejem: lsusb -v -d 1d6b:0002
	-t muestra las asignaciones actuales de los dispositivos USB en forma de arbol jerarquico 
		ejem: lsusb -t [numero del bus]:[NUmero del Device]	


kmod - conjunto de herramientas para manejar tareas comunes con modulos del kernel de linux, como
-insertar
-eliminar
-enumerar
-verificar propiedades
-resolver dependencias
-alias

lsmod - muestra los modulos cargados actualmente, en formato (nombre del modulo) (cantidad de memoria ram ocupada por el modulo en bytes) (modulos dependientes)

*Algunos modulos requieren de otros modulos para funcionar



modprpbe - usado para cargar como para descargar modulos especificos 
	-r eliminar un modulo

modinfo - muestra informacion sobre un modulo de kernel
	-p muestra todos los parametros disponibles e ignora la otra inf

*los parametros personalizados  de un modulo pueden hacerse persistentes al incluirlos en el archivo /etc/modprobe.conf o en archivos individuales con la extension .conf en el directorio /etc/modproble.d
	-p muestra todos los parametros disponibles e ignora la otra info

*si que quiere modificar un parametro, los podemos ver con -p, el cual nos muestra las opciones

*si un modulo esta causando problemas lo agregamos en /etc/modprobe.d/blacklist.conf

************Puede modificar el archivo /etc/modprobe.d/blacklist.conf que ya existe en el sistema de forma predeterminada. Sin embargo, el método preferido es crear un archivo de configuración separado, /etc/modprobe.d/<module_name>.conf, que contendrá configuraciones específicas solo para el módulo del núcleo dado


Archivos de informacion y archivos de dispositivos
La info que obtenemos con los comandos anteriores, se guarda en archivos especiales como /proc o /sys, presentes solo en RAN y no como una particion y solo existen mientras el sistema se esta ejecutando

/proc - tiene  archivos con informacion sobre proceso en ejecucion y recursos de hardware, algunos arhcivos importante dentro de esta dir son:
	/proc/cpuinfo - enumera info detalla da sobre la CPU
	/proc/interrups - lista de numero de las interrupciones por dispositivos de entrada/salida para CPU
	/proc/ioports - enumera los puertos de entrada/salida registrados actualmente en uso
	/proc/dma - Enumera los canales DMA (acceso directo a memoria registrados en uso)

/sys - tiene el propocito especifico de almacenar informacion del dispositivo y datos del kernel relacionados con el hardware

/dev - Cada archivo dentro de /dev esta asociado a un dispositivo del sistema, particularmente dispositivos de almacenamiento, generalmente para su uso, ejmplo: mount /dev/sda1

 medida que se dectan nuevos dispotivos, udev busca una regla coincidente en las reglaspredefinidas almacenadas en el directorio /etc/udev/rules.d/. La distribucion proporciona las reglas mas importantes, pero se pueden agregar nuevas para casos especificos 


======================
Arranque del sistema
======================


BIOS (Basic Input/Output System)

    -Definición: Firmware almacenado en un chip de memoria no volátil en la placa base.
    -Proceso de Arranque:
        Se ejecuta el POST (Power-On Self-Test) para detectar fallas de hardware.
        Activa componentes básicos como video, teclado y medios de almacenamiento.
        Carga la primera etapa del gestor de arranque desde el MBR (Master Boot Record).
        La primera etapa llama a la segunda etapa del gestor de arranque, que carga el núcleo del sistema operativo.
    -Limitaciones: Se basa en el MBR y tiene un límite de 2 TB para el tamaño de las particiones. No puede leer sistemas de archivos modernos.

UEFI (Unified Extensible Firmware Interface)

    -Definición: Firmware más avanzado que reemplaza al BIOS, con capacidades mejoradas.
    -Proceso de Arranque:
        Se ejecuta el POST para detectar fallas de hardware.
        Activa componentes básicos como video, teclado y medios de almacenamiento.
        Lee definiciones de arranque almacenadas en NVRAM para ejecutar la aplicación EFI predefinida desde la partición ESP (EFI System Partition).
        Si la aplicación es un gestor de arranque, carga el núcleo del sistema operativo.
    -Ventajas: No se basa en el MBR, admite particiones de más de 2 TB y puede leer varios sistemas de archivos (FAT12, FAT16, FAT32). Incluye características como Secure Boot, que permite solo la ejecución de aplicaciones EFI firmadas, mejorando la seguridad.





El cargador de arranque 
El gestor de arranque mas popular de linuz en la arquitectura x86 es GRUB (Grand Unified Bootloader), tan pronto lo llame bios o uefi aparecen lso SO que hay en el sistema

**Algunas veces no aparecen, por lo que debemos de presionar "shift" en bios u en uefi se hace con "scape"

GRUB (Grand Unified Bootloader) es el gestor de arranque más utilizado en sistemas Linux x86. Al iniciar, GRUB muestra una lista de sistemas operativos disponibles. Si no aparece automáticamente, se puede invocar presionando Shift (o Esc en sistemas UEFI).

Desde el menú de GRUB, se pueden seleccionar núcleos y pasarles parámetros, que generalmente siguen el formato opción=valor. Algunos parámetros útiles incluyen:

    acpi: Habilita/deshabilita el soporte ACPI (ej. acpi=off).
    init: Establece un iniciador alternativo (ej. init=/bin/bash).
    systemd.unit: Define el objetivo de systemd a activar (ej. systemd.unit=graphical.target).
    mem: Limita la RAM disponible (ej. mem=512M).
    maxcpus: Limita el número de procesadores visibles (ej. maxcpus=2).
    quiet: Oculta mensajes de arranque.
    vga: Selecciona un modo de video (ej. vga=ask).
    root: Establece la partición raíz (ej. root=/dev/sda3).
    ro/rw: Define el modo de montaje del sistema de archivos raíz (solo lectura o lectura/escritura).

Para hacer que los cambios en los parámetros sean persistentes, se deben agregar al archivo /etc/default/grub en la línea GRUB_CMDLINE_LINUX y luego ejecutar grub-mkconfig -o /boot/grub/grub.cfg para regenerar la configuración de GRUB. Los parámetros utilizados en la sesión actual se pueden ver en /proc/cmdline.





Inicializacion del sistema 
La inicialización del sistema operativo comienza cuando el gestor de arranque carga el núcleo en la RAM. El núcleo toma el control de la CPU y configura aspectos fundamentales del 
sistema, como la detección de dispositivos y el direccionamiento de memoria.

A continuación, el núcleo abre el initramfs (initial RAM filesystem), que es un sistema de archivos temporal que contiene los módulos necesarios para acceder al sistema 
de archivos raíz "real". Una vez que el sistema de archivos raíz está disponible, el núcleo monta los sistemas de archivos configurados en /etc/fstab y ejecuta el primer programa, 
llamado init.

El programa init es responsable de ejecutar los scripts de inicialización y los demonios del sistema. Existen diferentes implementaciones de iniciadores, como systemd 
y Upstart. Después de cargar init, el initramfs se elimina de la RAM.


SysV standar - administrador de servicios badado en el estandar SysVinit controla que los demosnio y recursos estaran disposibles empleando el concepto de runlevels, los niveles enumerados 
		del 1 al 6 con propositos especificos

systemd - administrador midernos de sistemas y servicios con una capa de compatibilidad entre los comandos y niveles de ejecucion de SysVinit. La mayoria de las principales distros han adoptado este administrador sinedo el predeterminado

Upstart - Es igual que systemd, un susstituto de init. Su objetivo es acelerar el proceso de arranque, fue usado por ubuntu, sin embargo dio paso a systemd




INspeccion de inicializacion 
Tods los errores dan como resultaod un mensaje que puedn usarse para posterior inspeccion o correcion.

**El espacio donde el kernel almacena sus mensajes, incluido los mensajes de arrnauq se llama "kernel ring buffer"
Se guardan incluso cuando no se le muestran al usuario

dmes - muestra los mensjaes actuLES EN EL BUFFER  (( Mensajes del núcleo, enfocado en eventos de hardware y arranque, no persistente ))
	--clear: Se pierden todos los mensajes cuando se apaga el sistemao al ejecutar el comando -> dmesg --clear 


En sistemas basados en systemd, el comando es journalctl

journalctl (( Registros del sistema más amplios, incluye mensajes de servicios y aplicaciones, persistente y organizado. ))
	--list-boot: muestra una lista de numeros de arranque relativos al arranque actual, su hash de identificacion y las marcas de tiempo del primer y ultimo mensaje correspondiente
	-b 0  o  --boot=0 mensajes para el arranque actual
	-b 1  o  --boot=1 mostraran mensajes de la inicializacion anterior
	-D o --direcory se puede usar para leer mensajes de registros en directorios que no sean /var/log/journal, que es el lugar predeterminado para los mensajes de registro de systemd
		**Como los mensajes de registro de systemd se almacenan en texto sin formato, se requiere el comando journalctl para leerlos 



la principal diferencia entre dmesg y journalctl es que el primero muestra mensajes del nucleo, enfocado en hardware y arranque y el segundo son registros mas aplios, agregando ademas de 
estos dos ultimos, lo de mensajes de servicios, plicacion

Los mensajes emitidos por el sistema, se almacenan en archivos dentro del direcorio /var/log/
	




=========================================================================================
Cambiar los niveles de ejecucion / objetivos de arrnauwe y apagar o reiniciar el sistema
=========================================================================================
Una carcateristica de los sitems linux es que siguen los principios de diseño unix, es el empleo para controlar distintas funciones del sistema, estos procesos se llaman daemons o genralmente "services" 

Cada dittribucion linux ofrece alguna utilidad de administracion de servicios para controlar el sistema
	Los servicios pueden ser controlados por scripts de shell o por un programa y sis archivos de configuracion compatibles

-El primer metodo lo implementa el standar SysVinit, conocido como System V
-El segundo metodo es implementado por systemd y Upstart


**El administrador de servicios es el primer programa lanzado por el nucleo durante el proceso de arranque, por loo que su PID (Numero de identificacion del proceso) SIEMPRE ES 1




Estandar SysVinit
En este estandar proporcionara conjuntos predefinidos de estados del sistema, llamados runlevels y sus correspondientes archivos de scrip de servicio pars ser ejecutados
Los servicios de ejecucion estan enumerados de 0 a 6, generalmente se asignan a los siguientes propositos:

Runlevel 0: apagado del sistema
Runlevel 1,s o usuario unico: apagado del sistema
Runlevel 2,3 o 4: Modo multiusuario. Los usuarios pueden iniciar sesion por consola o red. Los niveles de ejecucion 2 y 4 no se usan con frecuencia
Runlevel 5: Modo multiusuario. Es equivalente a 3, mas el inicio de sesion en modo grafico
Runlevel 6: Reinicio del sistema

El programa responsable de administrar los niveles de ejecuion y los demonios/recursos asociados es /sbin/init

-Cuando se inicia, se reconocne el nivel de ejecucion, definido en el parametro del nucleo del sistema operativo o en el archivo /etc/inittab
-Despues se cargan los scripts asociados que se enumeran alli para el nivel de ejecucion dado
	**Cada nivel de ejecion tienen  muchos archivos de servicio asociados, generalmente scripts en el directorio /etc/init.d/

**Los scripts usados por init  cuando se configura cada nivel se almacenan en el directorio /etc/init.d
  Cada nivel de ejecucion tienen un directorio asociado en /etc/, llamado /etc/rc0.d, /etc/rc1.d, los archvios tienen una K o una S, donde k es kill y se eliminara al ingresaar el nivel de ejecucion y s start, el cual se iniciara al ingresar el nivel de ejecucion
	ejem:El directorio /etc/rc1.d/ tendra muchos enlaces a los scripts de red que comienzan con la letra K, considerando que el nivel de ejeciion 1 corresponde un solo usuario sin conectividad de red

runlevel - muestra el nivel de ejecucion actual para el sistema
		ejem de salida: N 3 -> donde N muestra el nivel de ejecucion no ha cambiado desde el ultimo arranque, el runlevel 3, es el nivel de ejecucion actual del sistema.
		--> si por ejemplo estabamos en primera instancia en el multi.user.target, el runlevel	sera N 3, Y SI cambiamos a graphical.target y volvemos a ejecutar el comando runlevel
			nuestro resultado sera 3 5, pues cambio del runlevel 3 al 5, que es el grafico
	el mismo prorama init se puede usar para alternar entre niveles de ejecucion en un sistema, sin reiniciar. El comando telinit tambien se puede usar para laternar entre los niveles
	ejem: telinit 1, telinit s o telinit S, cambiaran el sistema al nivel de ejeccuion 1 


Advert:Como no todos los niveles de ejecución son equivalentes a través de diferentes distribuciones de Linux, también se puede encontrar una breve descripción del propósito del nivel de ejecución en las distribuciones basadas en SysV


La sintaxis del archivo /etc/inittab usa el formato: id:runlevels:action:process
-id: es un nombre generico de hasta 4 char para identificar la entrada
runlevels:lista de numeros de niveles para los que se debe ejecutar una accion especifica
action:define como init ejecutara el proceso indicado por el termino process, algunas acciones son:
	-boot:El proceso se ejecutará durante la inicialización del sistema. El campo runlevels se ignora.
	bootwait:El proceso se ejecutará durante la inicialización del sistema e init esperará hasta que termine para continuar. El campo runlevels se ignora.
	sysinit:El proceso se ejecutará después de la inicialización del sistema, independientemente del nivel de ejecución. El campo runlevels se ignora.

En la entrada id:x:initdefault del archivo /etc/inittab, la X es el numero de ejecucion predeterminado (nunca ser 0 o 6 ya que provocaria que se apagara o se reiniciara)

Cuando se termina de modificar el archivo /etc/inittab, debe de ejecutarse el comando telinit q, donde q le ordena que vuelva a cargar la configuracion 



Estandar Upstart
Los scripts de inicializacion se encuentran en /etc/init/
Los servicios del sistema se pueden enumerar con el comando initctl list, que tambien muestra el estado actual de los servicios y, si esta dispoible, su numero PID

Cada accion de upstart tiene su propio comando independiente, por ejemplo:
	start puede usarse para iniciar la sexta terminal virtual:
		start tty6

	ver estado actual de un recurso se puede verificar con el comando status
		status tty6

	interrupcion de un servicio, se usa el comando stop
		stop tty6

**Upstart no usa el archivo /etc/inittab para definir los niveles de ejecucion, pero los comandos heredados runlevel y telinit se poueden usar para verificar y alternar entre los niveles de ejecicion
**Upstart fue desarrollado para la distribución Ubuntu Linux para ayudar a facilitar el inicio paralelo de los procesos. Ubuntu ha dejado de usar Upstart desde 2015 cuando cambió de Upstart a systemd



Estandar Systemd
Es el mas utilizado para administrar los recursos y servicios del sistema, que system diminuia unidades (units)
	una unidad consta de nombre, tipo y un archivo de configuracion correspondiente, hay 7 tipos de unidades correspondientes


service: El tipo de unidad más común, para recursos activos del sistema que se pueden iniciar, interrumpir y recargar.

socket: El tipo de unidad de socket puede ser un socket de sistema de archivos o un socket de red. Todas las unidades de socket tienen una unidad de servicio correspondiente, cargada cuando el socket recibe una solicitud.

device:Una unidad de dispositivo está asociada con un dispositivo de hardware identificado por el núcleo. Un dispositivo solo se tomará como una unidad systemd si existe una regla udev para este propósito. Se puede usar una unidad de dispositivo para resolver dependencias de configuración cuando se detecta cierto hardware, dado que las propiedades de la regla udev se pueden usar como parámetros para la unidad de dispositivo.

mount:Una unidad de montaje es una definición de punto de montaje en el sistema de archivos, similar a una entrada en /etc/fstab.

automount:Una unidad de montaje automático también es una definición de punto de montaje en el sistema de archivos, pero se monta automáticamente. Cada unidad de montaje automático tiene una unidad de montaje correspondiente, que se inicia cuando se accede al punto de montaje automático.

target:Una unidad target es una agrupación de otras unidades, administradas como una sola unidad.

snapshot:Una unidad snapshot es un estado guardado del administrador del sistema (no disponible en todas las distribuciones de Linux)


systemctl - comando principal para controlar las unidades de systemd
		**udado para ejecutar todas las tareas relacionadas con la activacion, desactivacion, ejecucion, interrupcion, monitoreo de la unidad, etc



para un ejemplo, usaremos la unidad ficticia unit.target
iniciar: systemctl start unit.service
detener: systemctl stop unit.service
reinciar: systemctl restart unit.service
mostrar estado: systemctl status unit.service
verificar si una unidad esta activa: systemctl is-active unit.service
habilitar una unidad para que se inicie desde el inicio: systemctl enable unit.service
deshabilitar una unidad para que no se inicie desde el inicio: systemctl disable unit.service
verificar si se incia desde el inicio: systemctl is-enabled unit.service
ver el archivo de configuracion de unit de un servicio: systemctl cat ssh
muestra un arbol de dependencias de una unidad: systemctl list-dependencies ssh   --> si ejecutamos solo systemctl list-dependencies solo nos muestra la lista de dependencias del default.target 
ver unidades todas las unidades activas: systemctl 
listar todos los archivos de unidad en el sistema: systemctl list-unit-files


              : sytemctl isolate multi-user.target

Para cambiar el objetivo principal del sistema, la opcion systemd.unit se puede usar en la lista de parametros del nucleo del sistema operativo
	ejem:systemd.unit=multi-user.target

Otra forma es cambiar el enlse simbolico de /etc/systemd/system/default.target para que apunte al deseado, para hacerlo se puede hacer con el comando
	systemctl set-default multi.user.taget --> si vemos el archivo default.target, veeremos que se cambio al elegido

Para saber cual el objetivo, podemos ver el archivo o ejecutar systemctl get-default 

>>>Al igual que con SysVinit
***Nunca debe de apuntar al target de apagado del sistema 



****LOS ARCHIVOS DE CONFIGURACION DE CADA UNIDAD SE PUEDEN ENCONTRAR EN EL DIRECTORIO /LIB/SYSTEMD/SYSTEM/
systemctl list-units-files enumera todas las unidades disponibles
	                  --type=target o type=service --> para ver un ddeterminado tipo de units

systemctl suspend - suspendera el sistema en modo de bajo consumo, mantenidno los datos en memoria al disco
systemctl hibernate - copiara todos los darros de la memoria al disco, por lo que el sistema se recupera despues de apagarlo  


El demonio acpid es el principal adminsitrador de energia para linux y permite ajustes mas precisos a las acciones posteriores a eventos relacionados con la ejergia, como cerrar la tapa del portatil, bateria baja o niveles de carga de la bateria 




Apagado y Reinicio 
shutdown - comando muy tradicional para apagar o reiniciar el sistema

Este comando adiciona algunas funcionalidades, pudiendo notificar automaticamente a todos los usuarios conectados con un mensaje de advertencia en las sesiones de shell evitando mas conexiones 

**El comando shutdown actua como intermediario para los procedimientos SysV o systemd, es decir, ejecuta la accion solicitada llamando a la accion correspondiente en el administrador de servicios adoptado por el sistema

--> Despues de ejecutar shutdown, todos los procesos reciben la señal SIGTERM, seguida de la señal SIGKILL

las opciones -h o -r, el sistema alterna al nivel de ejecucion 1, osea al modo de usuario unico

Sintaxis:
	shutdown [option] time [message]
- solo se requiere el parametro time, el cual define cuando se ejecutara la accion y puede tener los siguiente formatos
	-> hh:mm	hora minutos
	-> +m	Especifica cuantos minutos esperar antes de la ejecucion 
	-> now o +0	Determina la ejecucion inmediata 

El parametro message es el texto de advertencia enviado a todas las sesiones de terminal de los usuarios conectados 
 

El comando systemctl se puede usar tambien para apagar o reiniciar la maquina del sistema como:
	systemctl reboot
	systemctl poweroff
ambos necesitan ser root para ejecutarse 

**algunas distros vinculan poweroff y reboot a systemctl como comndos individuales, por lo que podemos ejecutar estos comandos como
	reboot
	poweroff


Es importante notificar a los usarios antes de hacer un apagapn para evitar interrupcion de actividades
Se puede enviar un mesnaje broadcasr con wall
	wall "Se apagara el sistema en 10 segundos"


