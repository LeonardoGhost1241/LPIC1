==========================================================
103.1 Trabajando en la línea de comandos
==========================================================
->Leccion 1 

EJERCICIOS GUIADOS 
	-Utilice el sistema man para determinar cómo decirle a apropos que envíe un comando breve para que solo envíe un mensaje corto de uso y luego salga.
	Ejecute man apropos y desplácese hacia abajo por la sección “Options” hasta llegar al párrafo --usage.

	-Utilice el sistema man para determinar qué licencia de copyright se asigna al comando grep.
	Ejecute man grep y desplácese hacia abajo a la sección “Copyright” del documento. Tenga en cuenta que el programa utiliza los derechos de autor de la Free Software Foundation


EJERCICIOS EXPLORATORIOS 
	-Identifique la arquitectura de hardware y la versión del kernel de Linux que se utiliza en su computadora en un formato de salida fácil de interpretar.
	Usamos uname -iv 

	-Imprima las últimas veinte líneas de la base de datos dinámica history y el archivo .bash_history para compararlos.
	podemos usar tail, cat bash_history | tail -n 20, son muy diferentes los arhcivos,

	-Utilice la herramienta apropos para identificar la página man donde encontrará el comando que necesitará para mostrar el tamaño de un dispositivo de bloque físico conectado en 
	 bytes en lugar de megabytes o gigabytes.
	Una forma sería ejecutar apropos con la cadena block, leer los resultados, observar que lsblk enumera los dispositivos de bloque (y, por lo tanto, sería la herramienta más adecuada para nuestras necesidades), ejecutar man lsblk, desplácese por la sección “Description” y observe que -b mostrará el tamaño del dispositivo en bytes. Finalmente, ejecute lsblk -b para visualizar la salida.
	$ apropos block
	$ man lsblk
	$ lsblk -b

->Leccion 2
EJERCICIOS GUIADOS 
	-Use el comando export para agregar un nuevo directorio a su ruta (este no debe sobrevivir a un reinicio).
	podemos hacer un ejemplo con la variable PATH, agregando un nuevo directorio, la linea de ejecucion, se veria como: export PATH="$PATH:/new/dir", si quieres que sea permanente, debes de agregarla al archivo ~/.bashrc o ~/.bash_profile 

	-Use el comando unset para eliminar la variable PATH. Intente ejecutar un comando (como sudo cat /etc/shadow) usando sudo. ¿Que pasó? ¿Por qué? (Al salir de su shell, volverá a su estado original).
	Es como si desaparecieran los comandos, Por que la variable PATH contiene el directorio en donde debe de buscar los comandos y al eliminarla, dejan de "existir"

EJERCICIOS EXPLORATORIOS 
	-Busque en Internet para encontrar y explorar la lista completa de caracteres especiales.
	Lista de ejemplo: & ; | * ? " ' [ ] ( ) $ < > { } # / \ ! ~

	-Intente ejecutar comandos usando cadenas formadas por caracteres especiales y usando varios métodos para escaparlos. ¿Hay diferencias entre la forma en que se comportan esos métodos?
	Escapar usando caracteres " conservará los valores especiales del signo de dólar, una barra invertida y la barra invertida. Escapar usando un carácter ' hará que todos los caracteres sean literales.
	$ echo "$mynewvar"
	goodbye
	$ echo '$mynewvar'
	$mynewvar



==========================================================
103.2 Pricesosar secuecnias de texto usando fltros
==========================================================
EJERCICIOS  GUIADOS
	-Alguien acaba de donar una computadora portátil a su escuela y ahora desea instalar Linux en ella. No hay manual y se vio obligado a arrancarlo desde una unidad de memoria USB sin gráficos en absoluto. Obtiene acceso a un terminal de shell y se conoce, para cada procesador que tenga, habrá una línea para él en el archivo /proc/cpuinfo:
	processor	: 0
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158
	
	(líneas saltadas)

	processor	: 1
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158

	(se saltaron más líneas)
	Usando los comandos grep y wc muestre cuántos procesadores tiene.  --> grep "processor" /proc/cpuinfo | wc -l   o cat /proc/cpuinfo | grep processor | wc -l
	Haga lo mismo con sed en lugar de grep.  --> sed "/processor/p" < /proc/cpuinfo | wc -l 


	-Explore su archivo local /etc/passwd con los comandos grep, sed, head y tail según las siguientes tareas:
	¿Qué usuarios tienen acceso a un shell Bash?  --> cat /etc/passwd | grep "/bin/bash" | wc -l    o  sed -n "/\/bin\/bash/p" < /etc/passwd 
	Su sistema tiene varios usuarios que existen para manejar programas específicos o para fines administrativos. No tienen acceso a un shell. ¿Cuántos de esos existen en su sistema?  --> grep "nologin" $file | wc -l o sed -n "/nologin/p" $file | wc -l  oo  grep -v ":/bin/bash$" $file | wc -l
	¿Cuántos usuarios y grupos existen en su sistema (recuerde: use solo el archivo /etc/passwd)? --> cut -d ":" -f 3 $file | sort -un  | wc -l  y para los grupos seria cut -d ":" -f 4 $file | sort -un  | wc -l
	Muestre solo la primera línea, la última línea y la décima línea de su archivo /etc/passwd. head -n1  $file, tail -n1  $file, sed -n "10p" $file


	-Considere este ejemplo de archivo /etc/passwd. Copie las líneas siguientes en un archivo local llamado mypasswd para este ejercicio.
	root:x:0:0:root:/root:/bin/bash
	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
	bin:x:2:2:bin:/bin:/usr/sbin/nologin
	sys:x:3:3:sys:/dev:/usr/sbin/nologin
	sync:x:4:65534:sync:/bin:/bin/sync
	nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
	libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
	libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
	carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
	dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
	emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash

    Liste todos los usuarios en el grupo 1000 (use sed para seleccionar solo el campo apropiado) de su archivo mypasswd.
	sed -n "/1000:[A-Z]/p" passwd 

    Liste solo los nombres completos de todos los usuarios de este grupo (use sed y cut)
	sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5


EJERCICIOS EXPLORATORIOS
	-Una vez más, utilizando el archivo mypasswd de los ejercicios anteriores, idee un comando Bash que seleccionará a una persona de la Oficina Principal para ganar un concurso de rifas. 
	Use el comando sed para imprimir solo las líneas de la Oficina Principal, y luego una secuencia de comando cut para recuperar el nombre de cada usuario de estas líneas. A continuación, 
	deseará ordenar aleatoriamente estos nombres y solo imprimir el nombre superior de la lista.
		sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5 | sort -R 

	-¿Cuántas personas trabajan en Finanzas, Ingeniería y Ventas? (Considere explorar el comando uniq).
		 sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 | uniq -c 
	
	
	-Ahora desea preparar un archivo CSV (valores separados por comas) para poder importar fácilmente, desde el archivo mypasswd del ejemplo anterior, el archivo names.csv a LibreOffice. 
	El contenido del archivo tendrá el siguiente formato:
	First Name,Last Name,Position
	Carol,Smith,Finance
	...
	John,Chapel,Sales
	Consejo: Utilice los comandos sed, cut y paste para lograr los resultados deseados. Tenga en cuenta que la coma (,) será el delimitador de este archivo.
	Para este ejercicio, crearemos/ejecutaremos 4 passos, uno para nombres, otro para apellidos, otro para las posiciones y el ultimo lo juntaremos con el comando paste con la opcion -d que significa delimitador, entonces, nuestros pasos serian:
		1.- touch names && echo "Firs Name" > names && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 1 >> names
		2.- touch lnames && echo "Last Name" > lnames && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 2 >> lnames
		3.- touch position && echo "Position" > position  && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 >> position
		4.- paste -d "," names lnames position	> names.csv
		

	-Supongamos que la hoja de cálculo names.csv creada en el ejercicio anterior es un archivo importante y queremos asegurarnos de que nadie lo manipulará desde el momento en que se 
	 lo enviamos a alguien y el momento en que nuestro destinatario lo recibe. ¿Cómo podemos asegurar la integridad de este archivo usando md5sum?
		Lo podemos hacer con varios tipos de hash como md5sum, sh256sum, etc
			sha512sum names.csv 
			sha256sum names.csv 
			md5sum names.csv  --> 2c1b307d6535cd0943a01b87c855e181

	-Te prometiste a ti mismo que leerías un libro clásico de 100 líneas por día y decidiste comenzar con Mariner y Mystic de Herman Melville. 
	 Diseñe un comando usando split que separe este libro en secciones de 100 líneas cada una. Para obtener el libro en formato de texto plano, búsquelo en https://www.gutenberg.org.
		split -l 100 -d pg50461-images.html  parte


	-Usando ls -l en el directorio /etc, ¿qué tipo de listado obtiene? Usando el comando cut en la salida del comando ls dado, 
	 ¿cómo mostraría solo los nombres de archivo? ¿Qué pasa con el nombre del archivo y el propietario de los archivos? Junto con los comandos ls -l y cut, utilice el 
	 comando tr para suprimir las apariciones múltiples de un espacio en un solo espacio para ayudar a formatear la salida con un comando cut.
		Para mostrar solo los nombres de los arhcivos, podemos hacer lo siguiente
			ls -l | rev | cut -d " " -f 1 | rev
			o podemos usar el comando tr, como: ls -l | tr -s " " | cut -d " " -f 9
			Si necesitamos el nombre del archvios y el propietario necesitaremos las columnas 3 y 9  	
			como: ls -l | tr -s " " | cut -d " " -f9,3
			y si queremos el nombre de las carpetas y el propietario usaremos
			ls -l | grep ^d | tr -s " " | cut -d " " -f9,3
	
	
	-Este ejercicio asume que está en una máquina real (no en una máquina virtual). También debe tener una memoria USB con usted. 
	 Revise las páginas del manual para el comando tail y descubra cómo seguir un archivo a medida que se le agrega texto. 
	 Mientras monitorea la salida de un comando tail en el archivo /var/log/syslog, inserte una memoria USB. 
	 Escriba el comando completo que usaría para obtener el Producto, el Fabricante y la cantidad total de almacenamiento de su memoria USB.
		Podemos usar tail -f para monitorear registros o cualquier archivo que se actualice en tiempo real
		Sabiendo eso, podemos usar el comando sed para filtrar las opcioones que nos interesan, como el producto, el fabricante y la cantidad total de almacenamiento, el comando seria
			sed -n -e "/Product:/p" -e "/Manufacturer:/p" -e "/logical blocks:/p" /var/log/syslog
		o podemos usar el comando grep con la opcion -i que no distingue entre mayusculas o minusculas y ademas usaremos |, por lo que el comando seria
			tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
				\|: Este es el operador que actúa como un "O" lógico en expresiones regulares. Significa que se debe buscar cualquiera de los patrones conectados por él. En este caso, indica que también se buscará el siguiente patrón si no se encuentra el primero.


==========================================================
103.3 Gestion basica de archivos
==========================================================
->Leccion 1
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ ls -lh
	total 60K
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Desktop
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Documents
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Downloads
	-rw-r--r--  1   frank   frank     21    Sep 7   12:59   emp_name
	-rw-r--r--  1   frank   frank     20    Sep 7   13:03   emp_salary
	-rw-r--r--  1   frank   frank   8.8K    Apr 1   2018    examples.desktop
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file1
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file2
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Music
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Pictures
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Public
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Templates
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Videos

	    ¿Qué representa el caracter d en la salida? --> un directorio
	    ¿Por qué los tamaños se dan en formato legible para humanos? --> por que hemos usado la opcion -h del comando ls
	    ¿Cuál sería la diferencia en la salida si se usara ls sin argumentos? --> solo nos mostrar el contendio sin lo demas, como enlaces, nombre, grupo, etc
	
	-Considere el siguiente comando:
	$ cp /home/frank/emp_name /home/frank/backup
	    ¿Qué pasaría con el archivo emp_name si este comando se ejecuta con éxito? --> Copiaria el mismo contenido de emp_name a un nuevo archivo llamado backup
	    Si emp_name era un directorio, ¿qué opción debería agregarse a cp para ejecutar el comando?  --> -r, para que la accion sea recursiva
	    Si cp ahora se cambia a mv, ¿qué resultados espera? --> que solo se cambie de nombre, pero que tenga el mismo contenido (emp_name se movería a backup. Ya no estaría presente dentro del directorio de usuario frank.)
	
	-Considere el listado:
	$ ls
	file1.txt file2.txt file3.txt file4.txt
	¿Qué wildcard ayudaría a eliminar todo el contenido de este directorio? --> podriamos usar rm con el wildcard de * commo rm file*, pero eso es solo para estos archivos, si no queremos nada usamos rm *
	
	-Según el listado anterior, ¿qué archivos se mostrarían con el siguiente comando?
	$ ls file*.txt
		Todos los arhivos, ya que todos cumplen con el patron especificado, otra forma seria, ls file[1-4].txt
	
	-Complete el comando agregando los dígitos y caracteres apropiados entre corchetes que listarían todo el contenido anterior:
	$ ls file[].txt
	quedaria como ls file[0-9].txt -> NOTA:si tenemos archivks que superan el 9, podemos usar las llaves, como: ls file{1-13}.txt



EJERCICIO EXPLORATORIOS 
	-En su directorio de inicio, cree los archivos llamados dog y cat.
		touch dog cat
	
	-Aún en su directorio de inicio, cree el directorio llamado animal. Mueva dog y cat a animal.
		mkdir animal && mv dog cat animal	-> puede ocupar mv dog cat -t animal/, donde -t significa mover todos los arguentos fuente al directorio

	-Vaya a la carpeta Documents que se encuentra en su directorio de inicio y dentro, cree el directorio backup.
		cd Documents && mkdir backup	

	-Copie animal y su contenido en backup.
		cp -r ../animal/ backup/
	
	-Cambie el nombre de animal en backup a animal.bkup.
		mv animal animal.bkup	

	-El directorio /home/lpi/bases de datos contiene varios archivos incluyendo: db-1.tar.gz, db-2.tar.gz y db-3.tar.gz. ¿Qué comando único puede usar para listar solo los archivos mencionados anteriormente?
		ls -l db-[1-3]* o ls -l db-[1-3].tar.gz o ls -l db-{1..3}.tar.gz

	-Considere el listado:
	$ ls
	cne1222223.pdf cne12349.txt cne1234.pdf
	Con el uso de un solo carácter globbing, ¿qué comando eliminaría solo los archivos pdf?
		rm *.pdf


->Leccion 2
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ find /home/frank/Documents/ -type d
	/home/frank/Documents/
	/home/frank/Documents/animal
	/home/frank/Documents/animal/domestic
	/home/frank/Documents/animal/wild
	    ¿Qué tipo de archivos generaría este comando?  --> Directorios, ya que la opcion -type tiene d 
	    ¿En qué directorio comienza la búsqueda? --> En el directorio /hom/frank/Documents
	
	-Un usuario desea comprimir su carpeta de respaldo. Él usa el siguiente comando:
	$ tar cvf /home/frank/backup.tar.gz /home/frank/dir1
	¿Qué opción falta para comprimir la copia de seguridad utilizando el algoritmo gzip?
	Falta la opcion -z y ademas el guion inicial, el comando seria:
		tar-czvf /home/frank/backup.tar.gz /home/frank/dir1
	
	
EJERCICIO EXPLORATORIOS 
	-Como administrador del sistema, es necesario realizar verificaciones regulares para eliminar archivos voluminosos. Estos voluminosos archivos se encuentran en /var y terminan con una extensión .backup.
	    * Escriba el comando, usando find, para localizar estos archivos: -->	 find /var -name "*.backup"
	    *Un análisis de los tamaños de estos archivos revela que varían de 100M a 1000M. Complete el comando anterior con esta nueva información, para que pueda ubicar 
	     esos archivos de respaldo que van desde 100M a 1000M: -->		find /var -name "*.backup" -size +100M -size -1000M 
	    *Finalmente, complete este comando, con la acción de eliminación para que se eliminen estos archivos: -->		find /var -name "*.backup" -size +100M -size -1000M -exec rm {} \;
														  -->	      o find /var -name "*.backup" -size +100M -size -1000M -delete 
	
	-En el directorio /var, existen cuatro archivos de respaldo:
	db-jan-2018.backup
	db-feb-2018.backup
	db-march-2018.backup
	db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía un archivo con el nombre db-first-quarter-2018.backup.tar: 
			--> tar -cvf db-first-quarter-2018.backup.tar  db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía el archivo comprimido y comprímalo usando gzip. Tenga en cuenta que el nombre del archivo resultante debe terminar con .gz:
		        --> tar -czvf db-first-quarter-2018.backup.tar.gz db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup



==========================================================
103.4 Usar flujo, tuberias y redireccionamientos 
==========================================================
-Leccion 1 
EJERCICIOS GUIADOS	
	-Además de los archivos de texto, el comando cat también puede trabajar con datos binarios, como enviar el contenido de un dispositivo de bloque a un archivo. 
	 Usando la redirección, ¿cómo puede cat enviar el contenido del dispositivo /dev/sdc al archivo sdc.img en el directorio actual?
		cta /dev/sdc > sdc.img
	
	-¿Cuál es el nombre del canal estándar redirigido por el comando date 1> now.txt?
		 Salida estandar o  stdout 
	
	-Después de intentar sobrescribir un archivo usando la redirección, un usuario recibe un error informando que la opción noclobber está habilitada. 
	 ¿Cómo se puede desactivar la opción noclobber para la sesión actual?
		set +o noclobber 
	
	¿Cuál será el resultado del comando cat <<.>/dev/stdout?
		Asi como  es e lformato de Here document, como <<EOF y finaliza con un EOF, podemos sustituir este EOF por un punto (.), por lo que es lo mismo.
		Entonces con cat le pasaremos una entrada cualauqiera (ya conoces como inicia la linea de Here Docuemnt ">") que a su ves, redirigiremos lo que hemos escrito a stdout, osease la salida de la temrinal, por lo que cuando demos enter, veremos el mismo texto
	
	
EJERCICIOS EXPLORATORIOS 
	-El comando cat /proc/cpu_info muestra un mensaje de error porque /proc/cpu_info no existe. El comando cat /proc/cpu_info 2>1 redirige el mensaje de error a dónde?
		El comando cat /proc/cpu_info 2>1 intentaria redirigir la salida de error a un archivo llamado 1, lo cual no es lo que se pretende. La redireccion correcta para ver los mensajes de error en la terminal seria usando 2>&1, 
		si queremos redirigir tanto la salida estandar como la salida de erro, deberiamos de unar &> o &>>

	-¿Será posible descartar el contenido enviado a /dev/null si la opción noclobber está habilitada para la sesión de shell actual?
		Si, /dev/null es un archivo especial no afectado por noclobber	

	-Sin usar echo, ¿cómo se podría redirigir el contenido de la variable $USER al stdin del comando sha1sum?
		Podemos usar  HERE STRING, sha1sum <<< $USER

	-El kernel de Linux mantiene enlaces simbólicos en /proc/PID/fd/ a cada archivo abierto por un proceso, donde PID es el número de identificación del proceso correspondiente. 
	 ¿Cómo podría el administrador del sistema usar ese directorio para verificar la ubicación de los archivos de registro abiertos por nginx, suponiendo que su PID sea 1234?
		ls -l /proc/1234/fd, que mostrara los objetivos de cada enlace simbolico en el directorio

	
	-Es posible hacer cálculos aritméticos utilizando solo comandos integrados de shell, pero los cálculos de coma flotante requieren programas específicos, como bc (basic calculator). 
         Con bc incluso es posible especificar el número de lugares decimales, con el parámetro scale. Sin embargo, bc acepta operaciones solo a través de su entrada estándar, 
         generalmente ingresada en modo interactivo. Usando una cadena Here, ¿cómo puede la operación de coma flotante scale = 6; 1 / 3 enviarse a la entrada estándar de bc?
		Lo podemos hacer con cadena Here String, como bc <<< "scale=6; 1/3"
	
	
-Leccion 2
EJERCICIOS GUIADOS
	-Es conveniente guardar la fecha de ejecución de las acciones realizadas por scripts automatizados. El comando date +%Y-%m-%d muestra la fecha actual en formato año-mes-día. 
	 ¿Cómo se puede almacenar la salida de dicho comando en una variable de shell llamada TODAY usando la sustitución de comandos?
		TODAY=$(date +%Y-%m-%d)
		echo $TODAY
	
	-Usando el comando echo, ¿cómo se puede enviar el contenido de la variable TODAY a la entrada estándar del comando sed s/-/./g?
	echo $TODAY | date sed s/-/./g 
	
	-¿Cómo podría usarse la salida del comando date +%Y-%m-%d como una cadena Here para ordenar sed s/-/./g?
		sed s/-/./g <<< `date +%Y-%m-%d`	
		o
		sed s/-/./g <<< $(date +%Y-%m-%d)

	-El comando convert image.jpeg -resize 25% small/image.jpeg crea una versión más pequeña de image.jpeg y coloca la imagen resultante en un archivo 
         con el mismo nombre dentro del subdirectorio small. Usando xargs, ¿cómo es posible ejecutar el mismo comando para cada imagen listada en el archivo filelist.txt?
	 		El comando convert es parte de la suite de herramientas de ImageMagick, que se utiliza para la manipulacion de imagenes. Este comando permite convertir, redimensionar y realizar diversas operaciones en imagenes en varios formatos, como
			las opciones mas comunes son:
				-resize 50%	o -resize 1920x1080
				-format 
		cat filelist.txt | xargs -I image convert image -resize 50% small/image
		o
		xargs -I image convert image -resize 25% small/image < filelist.txt

	


EJERCICIOS EXPLORATORIOS 
	-Una rutina de copia de seguridad simple crea periódicamente una imagen de partición /dev/sda1 con dd < /dev/sda1 > sda1.img. 
	 Para realizar futuras comprobaciones de integridad de datos, la rutina también genera un hash SHA1 del archivo con 
	 sha1sum < sda1.img > sda1.sha1. Al agregar tuberías y el comando tee, ¿cómo se combinarían estos dos comandos en uno?
		sha1sum sda1.img | tee sda1.sha1	



	-El comando tar se usa para archivar muchos archivos en uno solo, preservando la estructura del directorio. 
	 La opción -T permite especificar un archivo que contiene las rutas a archivar. 
	 Por ejemplo, find /etc -type f | tar -cJ -f /srv/backup/etc.tar.xz -T - crea un archivo tar comprimido etc.tar.xz de la lista provista por el 
	 comando find (la opción -T- indica la entrada estándar como la lista de ruta). 
	 Para evitar posibles errores de análisis debido a las rutas que contienen espacios, ¿qué opciones de comando deberían estar presentes para find y tar?
	las opciones -print0 y --null
		find /etc -type f -print0 | tar -cJ -f /srv/backup/etc.tar.xz --null -T -

	
	-En lugar de abrir una nueva sesión de shell remota, el comando ssh solo puede ejecutar un comando indicado como argumento: ssh user@storage "remote command". 
	 Dado que ssh también permite redirigir la salida estándar de un programa local a la entrada estándar del programa remoto, 
	 ¿cómo canalizaría el comando cat un archivo local llamado etc.tar.gz a /srv/backup/etc.tar.gz en user@storage a través de ssh?
		$ cat etc.tar.gz | ssh user@storage "cat > /srv/backup/etc.tar.gz"
		o
		$ ssh user@storage "cat > /srv/backup/etc.tar.gz" < etc.tar.gz



==========================================================
103.5 Crear, supervisar y matar procesos 
==========================================================
->Leccion 1

EJERCICIOS GUIADOS
	-oneko es un programa divertido y agradable que muestra un gato persiguiendo el cursor del mouse. Si aún no está instalado en su sistema de escritorio, 
	 instálelo utilizando el administrador de paquetes de su distribución. Lo usaremos para estudiar el control del trabajo.
	    Inicia el programa. ¿Cómo lo hace?
			oneko
	    Mueva el cursor del mouse para ver cómo lo persigue el gato. Ahora suspenda el proceso. ¿Cómo hace eso? ¿Cuál es el resultado?
			Lo ponemos hacer con el shortcut Ctrl + Z

	    Compruebe cuántos trabajos tiene actualmente. ¿Qué escribe? ¿Cuál es el resultado?
			jobs -l	

	    Ahora envíelo al segundo plano especificando su ID de trabajo. ¿Cuál es el resultado? ¿Cómo puede saber que el trabajo se está ejecutando en segundo plano?
			bg %%, como el esl unico, podmeos usar %% o %+, de otro modo debemos especificar %n, ejem: bg %1

	    Finalmente, finalice el trabajo especificando su ID de trabajo. ¿Qué escribes?
			kill %% o kill %1
	

	-Descubra los PID de todos los procesos generados por Apache HTTPD web server (apache2) con dos comandos diferentes:
		Podemos usar pgrep y ps aux | grep "apache*", la ejecucion de estos seria:
			pgrep apache2 o pidof apache2
			ps aux | grep "apache"

	-Termine todos los procesos apache2 sin usar sus PID y con dos comandos diferentes:
		Podemos usar killall o pkill
			killall apache2
			kill $(pgrep apache2)
			pkill apache2
	

	-Suponga que tiene que terminar todas las instancias de apache2 y no tiene tiempo para averiguar cuáles son sus PID. ¿Cómo lograría eso usando kill con la señal predeterminada SIGTERM en una línea:
		kill -s SIGTERM $(pgrep apache2), por defecto kill usa la señal predeterminada de 15 o SIGTERM, por lo que no es necesario utilizarlo, por lo tanto, kill $(pidof apache2)


	-Inicie top e interactúe con él realizando lo siguiente:
	    Mostrar una vista del bosque de pocesos: se usa la opcion V, nos mostrara los procesos en forma de arbol	
	    Muestra rutas completas de procesos que diferencian entre espacio de usuario y espacio de kernel: Se puede usar la opcion c, para mostrar las  rutas de cada comando
	
	-Escriba el comando ps para mostrar todos los procesos iniciados por Apache HTTPD web server usuario (www-data):
	    Usando la sintaxis BSD: ps U www-data
	    Usando la sintaxis UNIX: ps -u www-data
	    Usando la sintaxis de GNU: ps --user www-data



EJERCICIOS EXPLORATORIOS

	-La señal SIGHUP puede usarse como una forma de reiniciar ciertos demonios. Con Apache HTTPD web server, por ejemplo, enviar SIGHUP al proceso padre (el que comenzó con init) mata a sus hijos. 
	 Sin embargo, el padre vuelve a leer sus archivos de configuración, vuelve a abrir los archivos de registro y genera un nuevo conjunto de hijos. Realice las siguientes tareas:
	    Inicie el servidor web:  sudo systemct start apache2
	    Asegúrese de conocer el PID del proceso principal: ps aux | grep apche2
	    Haga que el servidor web Apache HTTPD se reinicie enviándole la señal SIGHUP al proceso principal:kill -s SIGHUP 
	    Verifique que el padre no haya sido terminado y que se hayan generado nuevos hijos: el proceso incial lo inicio el root, por lo que podemos usar:
												kill -1 4094
												kill -SIGHUP 4094
												kill -s SIGHUP 4094


	-Aunque inicialmente estático, la salida de ps puede volverse dinámica combinando ps y watch. Supervisaremos Apache HTTPD web server para detectar nuevas conexiones. 
	 Antes de realizar las tareas descritas a continuación, se recomienda que lea la descripción de la directiva MaxConnectionsPerChild en Apache MPM Common Directives.	
	    Agregue la directiva MaxConnectionsPerChild con un valor de 1 en el archivo de configuración de apache2 — en Debian y derivados se encuentran en /etc/apache2/apache2.conf; 
	    en la familia CentOS, en /etc/httpd/conf/httpd.conf. No olvide reiniciar apache2 para que los cambios surtan efecto.
		La línea a incluir en el archivo de configuración es MaxConnectionsPerChild 1. Una forma de reiniciar el servidor web es a través de sudo systemctl restart apache2.

	    Escriba un comando que use watch, ps y grep para las conexiones apache2.
		watch 'ps aux | grep apache2' o watch "ps aux | grep apache2"
	
	    Ahora abra un navegador web o use un navegador de línea de comandos como lynx para establecer una conexión con el servidor web a través de su dirección IP. ¿Qué observa en la salida de watch?
		Uno de los procesos secundarios propiedad de www-data desaparece.

	
	-Como has aprendido, por defecto, top clasifica las tareas por porcentaje de uso de CPU en orden descendente (los valores más altos en la parte superior). 
	 Este comportamiento se puede modificar con las teclas interactivas M (uso de memoria), N (identificador único del proceso), T (tiempo de ejecución) y P (porcentaje del tiempo de CPU). 
	 Sin embargo, también puede ordenar la lista de tareas a su gusto iniciando top con la opción -o (para obtener más información, consulte la página man de top). Ahora, realice las siguientes tareas:
	
	    Inicie top para que las tareas se ordenen por uso de memoria: se usa top -o %MEM
	    Verifique que envió el comando correcto resaltando la columna de memoria: se usa la opcion x
	

	-ps también tiene una opción "o" para especificar las columnas que desea que se muestren. Investigue esta opción y realice las siguientes tareas:
		(https://man7.org/linux/man-pages/man1/ps.1.html#STANDARD_FORMAT_SPECIFIERS)
	    Inicie ps para que solo se muestre información sobre usuario, porcentaje de memoria utilizada, porcentaje de tiempo de CPU utilizado y comando completo: ps -o user,%mem,%cpu,cmd
	    Ahora, ejecute ps para que la única información que se muestre sea la del usuario y el nombre de los programas que están utilizando: ps o user,comm


->leccion 2
EJERCICIOS GUIADOS

	-Indique si las siguientes declaraciones/características corresponden a la GNU Screen, tmux o ambos:
	Característica/Declaración					GNU Screen					tmux
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	El prefijo de comando predeterminado es Ctrl+a			    *
	Modelo cliente-servidor												 *
	Los paneles son pseudo-terminales				                                                 *
	Matar una región no mata sus ventanas asociadas			    *
	Las sesiones incluyen ventanas					    *						 *
	Las sesiones se pueden separar					    *						 *
			
	
	
	-Instale GNU Screen en su computadora (nombre del paquete: screen) y complete las siguientes tareas:	
	    Inicie el programa. ¿Qué comando utiliza?  --> screen 
	    Inicie top: --> usamos el comando top
	    Usando el prefijo de la tecla de pantalla, abra una nueva ventana; luego, abra /etc/screenrc usando vi: --> ctrl + a - c y despues ejecutamos vim /etc/screencr
	    Liste las ventanas en la parte inferior de la pantalla: ctrl + a - w  
	    Cambie el nombre de la ventana actual a vi: --> Ctrl + a - A
	    Cambie el nombre de la ventana restante a top. 
		Para hacer eso, primero muestre una lista de todas las ventanas para que pueda moverse hacia arriba y hacia abajo y seleccionar la correcta: Ctrl + a - w, despues seleccionamos la otra y cambiamos el nombre con Ctrl + a - A
	    Verifique que los nombres hayan cambiado volviendo a mostrar los nombres de las ventanas en la parte inferior de la pantalla: --> Ctrl + w
	    Ahora, separe la sesión y haga que screen cree una nueva llamada ssh: Ctrl + d, y creamos una nueva sesion con screen -S "ssh" y para listarlas usamos screen -ls  
	    Desconecte también de ssh y haga que screen muestre la lista de sesiones: Ctrl + d y para listarlas, usaremos screen -ls 
	    Ahora, adjunte a la primera sesión usando su PID: --> screen -r PID, podemos desvincularnos de una sesion con screen -d PID
	    Debería estar de vuelta en la ventana que muestra top. Divida la ventana horizontalmente y muévase a la nueva región vacía:  --> Ctrl + a - S, para movernos al siguiente panel, usaremos  Ctrl + a - Tab
	    Haga que screen enumere todas las ventanas y seleccione vi para que se muestre en la nueva región vacía: --> Ctrl + a - " y seleccionamos la que querramos
	    Ahora, divida la región actual verticalmente, muévase a la región vacía recién creada y asóciela con una nueva ventana: Ctrl + a - |, y para asociarla podemosusar Ctrl + a - w 
	    Termine todas las regiones excepto la actual (recuerde, aunque mate las regiones, las ventanas siguen vivas). Luego, salga de todas las ventanas de la sesión actual hasta que termine la sesión: Crtl + a - Q
	    Finalmente, haga que screen liste sus sesiones una vez más, elimine la sesión ssh restante por PID y verifique que en realidad no quedan sesiones: --> screen -S "ssh" -X quit y con screen -ls
	

	-Instale tmux en su computadora (nombre del paquete: tmux) y complete las siguientes tareas:	
	    Inicie el programa. ¿Qué comando utiliza? --> tmux 
	    Inicie top (observe cómo, en un par de segundos, el nombre de la ventana cambia a top en la barra de estado):
	    Usando el prefijo de clave de tmux, abra una nueva ventana; luego, cree ~/.tmux.conf usando nano: Ctrl + b - c, seguido de nano ~/tmux.conf
		Divida la ventana verticalmente y reduzca el tamaño del panel recién creado varias veces: --> Ctrl + b - % y para cambiar el tamaño usaremos ctrl + b manreniendolo mientras usamos las flechas para 			aumentar o reducir el tamaño 
	    Ahora cambie el nombre de la ventana actual a text editing; luego, haga que tmux muestre una lista con todas sus sesiones: Ctrl + b - ,  y para listar todas las sesiones usaremos ctrl + b - s 
	    Vaya a la ventana que ejecuta top y vuelva a la actual usando la misma combinación de teclas: se usa la misma c9mbinacion, ctrl + b + s y seleccionames la que queramos 	
	    Desconecte la sesión actual y cree una nueva cuyo nombre sea ssh y su nombre de ventana sea ssh window: --> para desconectarse usamos ctrl + b - d y para crear una nueva sesion usamos tmux new -s 				"name session" -n "ssh"
	    Desconecte también de la sesión ssh y haga que tmux muestre la lista de sesiones nuevamente: --> ctrl + b - s para mostrar las sesiones 
	
		    Note:A partir de este punto, el ejercicio requiere que utilice una máquina remota para las conexiones ssh a su host local (una máquina virtual es perfectamente válida y puede resultar realmente práctica). Asegúrese de tener openssh-server instalado y ejecutándose en su máquina local y que al menos openssh-client esté instalado en la máquina remota.
	    Ahora, inicie una máquina remota y conéctese a través de ssh con su host local. Una vez que se haya establecido la conexión, verifique las sesiones tmux: -->  tmux ls para ver las sesiones 
	    En el host remoto, adjunte a la sesión ssh por nombre: --> tmux attach-session -t "name sesion" / tmux attach -s "session name" / tmux at -s "session name " vinculamos una sesion 
	    De vuelta en su máquina local, conéctese a la sesión ssh por nombre, asegurándose de que la conexión al host remoto finalice primero:tmux a -d -t ssh (a puede ser reemplazarse por at o attach
	    Haga que todas las sesiones se muestren para su selección y vaya a su primera sesión ([0]). Una vez allí, mate la sesión ssh por su nombre: ctrl + b - s y para terminar la sesion ctrl + b  despues ejecutamos :kill-session -t 0 o ya en la sesion podemos usar ctrl + b - X para cerrar paneles 
	    Finalmente, desconéctese de la sesión actual y elimínela por su nombre: ctrl + b - d y para eliminarla tmux kill-session -t "name session"
	
	
	
EJERCICIOS EXPLORATORIOS	
	-Tanto screen como tmux pueden ingresar al modo de línea de comandos a través de prefijo de comando + : (ya vimos un breve ejemplo con tmux). Investigue un poco y realice las siguientes tareas en el modo de línea de comandos:
	    Haga que screen entre en el modo de copia: se puede usar ctrl + a -[  y despues presionamos ctrl + espacio y para copiar elcontenido 	
	    Haga que tmux cambie el nombre de la ventana actual:
	    Haga que screen cierre todas las ventanas y finalice la sesión:
	    Haga que tmux divida un panel en dos:
	    Haga que tmux elimine la ventana actual:
Haga que screen entre en el modo de copia:

Ctrl+a-: — después, teclee copy.

Haga que tmux cambie el nombre de la ventana actual:

Ctrl+b-: — después, teclee rename-window.

Haga que screen cierre todas las ventanas y finalice la sesión:

Ctrl+a-: — después, teclee quit.

Haga que tmux divida un panel en dos:

Ctrl+b-: — después, teclee split-window.

Haga que tmux elimine la ventana actual:

Ctrl+b-: — después, teclee kill-window.	


	-Cuando ingresa al modo de copia en screen, no solo puede usar las teclas de flecha y PgUP o PgDown para navegar por la ventana actual y el búfer de retroceso. También existe la posibilidad de utilizar un editor de pantalla completa similar a vi. Con este editor, realice las siguientes tareas:	
	    Echo supercalifragilisticexpialidocious en su terminal screen:
	    Ahora, copie los cinco caracteres consecutivos (de izquierda a derecha) en la línea justo encima de su cursor:
	    Finalmente, pegue la selección (stice) en su símbolo del sistema:
	
Echo supercalifragilisticexpialidocious en su terminal screen:
echo supercalifragilisticexpialidocious

Ahora, copie los cinco caracteres consecutivos (de izquierda a derecha) en la línea justo encima de su cursor:
Ingresamos al modo de copia: Ctrl+a-[ o Ctrl+a-: y luego escribimos copy. Luego, nos movemos a la línea de arriba usando k y presionamos espacio para marcar el comienzo de la selección. Finalmente, avanzamos cuatro caracteres usando l y presionamos espacio nuevamente para marcar el final de la selección.

Finalmente, pegue la selección (stice) en su símbolo del sistema:
Ctrl+a-]



	-Suponga que desea compartir una sesión tmux (our_session) con otro usuario. Ha creado el socket (/tmp/our_socket) con los permisos adecuados para que tanto usted como el otro usuario puedan leer y escribir. ¿Qué otras dos condiciones deben cumplirse para que el segundo usuario pueda adjuntar correctamente la sesión a través de tmux -S /tmp/our_socket a -t our_session?
Ambos usuarios deben tener un grupo en común, p. Ej. multiplexor. Luego, también debemos cambiar el conector a ese grupo: chgrp multiplexer /tmp/our_socket




==========================================================
103.6  Modificar las prioridades de ejecución de procesos 
==========================================================

EJERCICIOS GUIADOS
	    -En un sistema multitarea preventivo, ¿qué sucede cuando un proceso de menor prioridad ocupa el procesador y un proceso de mayor prioridad se pone en cola para su ejecución?
	    El proceso de menor prioridad se detiene y en su lugar se ejecuta el proceso de mayor prioridad.
	
	    -Considere la siguiente pantalla top:
	    top - 08:43:14 up 23 days, 12:29,  5 users,  load average: 0,13, 0,18, 0,21
	    Tasks: 240 total,   2 running, 238 sleeping,   0 stopped,   0 zombie
	    %Cpu(s):  1,4 us,  0,4 sy,  0,0 ni, 98,1 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
	    MiB Mem :   7726,4 total,    590,9 free,   1600,8 used,   5534,7 buff/cache
	    MiB Swap:  30517,0 total,  30462,5 free,     54,5 used.   5769,4 avail Mem
	
	      PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
	        1 root      20   0  171420  10668   7612 S   0,0   0,1   9:59.15 systemd
	        2 root      20   0       0      0      0 S   0,0   0,0   0:02.76 kthreadd
	        3 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_gp
	        4 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_par_gp
	        8 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 mm_percpu_wq
	        9 root      20   0       0      0      0 S   0,0   0,0   0:49.06 ksoftirqd/0
	       10 root      20   0       0      0      0 I   0,0   0,0  18:24.20 rcu_sched
	       11 root      20   0       0      0      0 I   0,0   0,0   0:00.00 rcu_bh
	       12 root      rt   0       0      0      0 S   0,0   0,0   0:08.17 migration/0
	       14 root      20   0       0      0      0 S   0,0   0,0   0:00.00 cpuhp/0
	       15 root      20   0       0      0      0 S   0,0   0,0   0:00.00 cpuhp/1
	       16 root      rt   0       0      0      0 S   0,0   0,0   0:11.79 migration/1
	       17 root      20   0       0      0      0 S   0,0   0,0   0:26.01 ksoftirqd/1
	
	    -¿Qué PIDs tienen prioridades en tiempo real?
	    PIDs 12 y 16, por que en el apartado de PR, hay rt, de runtime 
	
	    Considere la siguiente lista ps -el:
	
	    F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
	    4 S     0     1     0  0  80   0 - 42855 -      ?        00:09:59 systemd
	    1 S     0     2     0  0  80   0 -     0 -      ?        00:00:02 kthreadd
	    1 I     0     3     2  0  60 -20 -     0 -      ?        00:00:00 rcu_gp
	    1 S     0     9     2  0  80   0 -     0 -      ?        00:00:49 ksoftirqd/0
	    1 I     0    10     2  0  80   0 -     0 -      ?        00:18:26 rcu_sched
	    1 I     0    11     2  0  80   0 -     0 -      ?        00:00:00 rcu_bh
	    1 S     0    12     2  0 -40   - -     0 -      ?        00:00:08 migration/0
	    1 S     0    14     2  0  80   0 -     0 -      ?        00:00:00 cpuhp/0
	    5 S     0    15     2  0  80   0 -     0 -      ?        00:00:00 cpuhp/1
	
	    ¿Qué PID tiene mayor prioridad?
	    PID 12, por que tiene -20 de prioridad
	
	    -Después de intentar modificar un proceso con renice, ocurre el siguiente error:
	    $ renice -10 21704
	    renice: failed to set priority for 21704 (process ID): Permission denied
	    ¿Cuál es la causa probable del error?
	    Solo el usuario root puede disminuir los números nice por debajo de cero.
	

EJERCICIOS EXPLORATORIOS 
	    Por lo general, es necesario cambiar las prioridades del proceso cuando un proceso ocupa demasiado tiempo de CPU. 
	    Usando ps con opciones estándar para imprimir todos los procesos del sistema en formato largo, ¿qué valor de --sort ordenará los procesos por uso de CPU, aumentando el orden?	
	    $ ps -el --sort=pcpu (https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://man7.org/linux/man-pages/man1/ps.1.html&ved=2ahUKEwj9_8230rOQAxXIDkQIHVjlLo4QFnoECBkQAQ&usg=AOvVaw1NuIHmS-CDDnxGdZ_E1V3b)
	
	    El comando schedtool puede establecer todos los parámetros de programación de la CPU de los que Linux es capaz o mostrar información para procesos dados. 
	    ¿Cómo se puede utilizar para mostrar los parámetros de programación del proceso 1750? Además, ¿cómo se puede usar schedtool para 
	    cambiar el proceso 1750 a tiempo real con prioridad -90 (como se muestra en top)?
	    $ schedtool 1750
	    $ schedtool -R -p 89 1750
	
		donde R significa que debe de ejecutarse en un modod de prioridad en tiempo real
		-p Se esta especificadno la prioridad que se asignara al proceso identificado por su PID

==========================================================
103.7 Trabajando en la línea de comandos
==========================================================
->Leccion 1

EJERCICIOS GUIADOS 
	-¿Qué expresión regular extendida coincidiría con cualquier dirección de correo electrónico, como info@example.org?
		[[:alnum:]]@example\.org

	-¿Qué expresión regular extendida sólo coincidiría con cualquier dirección IPv4 en el formato estándar de cuatro puntos, como 192.168.15.1?
		"[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+" 
		"[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"

	-¿Cómo se puede usar el comando grep para listar el contenido del archivo /etc/services, descartando todos los comentarios (líneas que comienzan con #)?
		grep -v  -E "^#" lorem.txt 

	-El archivo domains.txt contiene una lista de nombres de dominio, uno por línea. ¿Cómo se usaría el comando egrep para listar solo los dominios .org o .com?
		egrep es lo mismo que grep -E 
			grep -E "\.com|\.org" lorem.txt 
			o grep -E "[[:alnum:]]+(\.org|\.com)" --> grep -E "[[:alnum:]]+(\.com|\.org)" lorem.txt 

		Opciones menos utiles
		grep -E "*.org|*.com"	
		grep -E "[[:alnum:]].com$|[[:alnum:]].org$"


EJERCICIOS EXPLORATORIOS
	-Desde el directorio actual, ¿cómo usaría el comando find con una expresión regular extendida para buscar todos los archivos que no contienen 
	 un sufijo de archivo estándar (los nombres de archivo que no terminan en .txt o .c, por ejemplo)?
--> Para mostrar arhcivos sin extensiones			#find $HOME -regextype posix-extended -type f ! -regex ".*\..*$"  --> .* significa todo o nada, por que el punto representa cualquier carcater y el * representa mas de una repeticion de cualquier carcater
		La respuesta para este ejercicio es: find -type f -regextype posix-extended ! -regex ".*\.(txt|c)$"


	-El comando less es el paginador predeterminado para mostrar archivos de texto largos en el entorno de shell. 
	 Al escribir /, se puede ingresar una expresión regular en el campo de búsqueda para saltar a la primera coincidencia correspondiente. 
	 Para permanecer en la posición actual del documento y sólo resaltar las coincidencias correspondientes, 
	 ¿qué combinación de teclas se debe ingresar en el campo de búsqueda?
		Presionando Ctrl+K antes de ingresar la expresión de búsqueda.

	-Con less, ¿cómo sería posible filtrar la salida para que sólo se muestren las líneas que coinciden con una expresión regular?
		Presionando & e ingresando la expresión de búsqueda.

==========================================================
103.1 Trabajando en la línea de comandos
==========================================================
EJERCICIOS GUIADOS
	-vi se usa principalmente como editor para archivos de configuración y código fuente, donde la sangría ayuda a identificar secciones de texto. 
	 Una selección se puede sangrar a la izquierda presionando < y a la derecha presionando >. ¿Qué teclas deben presionarse en modo normal para sangrar la selección actual tres pasos a la izquierda?
		Se puede usar 3<, el cual ejecuta tres veces 

	-Se puede seleccionar una línea completa presionando V en el modo normal vi. Sin embargo, también se incluye el carácter de nueva línea de terminación. 
	 ¿Qué teclas se deben presionar en modo normal para seleccionar desde el carácter inicial hasta el carácter de nueva línea, pero sin incluirlo?
		Las teclas 0v$h, que significan 0 (“saltar al inicio de una línea”), v (“iniciar la selección de caracteres”), $ (“ir al final de la línea”) y h (“retroceder una posición”).

	-¿Cómo debería ejecutarse vi en la línea de comando para abrir ~/.bash_profile y saltar directamente a la última línea?
		El comando vi + ~/.bash_profile abrirá el archivo y colocará el cursor en su última línea.

	-¿Qué teclas se deben presionar en el modo normal vi para eliminar caracteres desde la posición actual del cursor hasta el siguiente carácter de punto?
		Las teclas dt, que significan d (“iniciar eliminación”), t (“saltar al siguiente carácter”) y . (carácter de punto).


EJERCICIOS EXPLORATORIOS 
	-vim permite seleccionar bloques de texto con ancho arbitrario, no sólo secciones con líneas completas. Al presionar Ctrl+V en modo normal, 
	 se realiza una selección moviendo el cursor hacia arriba, abajo, izquierda y derecha. Con este método, 
	 ¿cómo se eliminaría un bloque que comienza en el primer carácter de la línea actual, que contiene las siguientes ocho columnas y cinco líneas de texto?
		La combinación 0, Ctrl-V y 8l5jd seleccionará y eliminará el bloque correspondiente.

	-Una sesión vi fue interrumpida por una falla de energía inesperada. Cuando se vuelve a abrir el archivo, 
	 vi pregunta al usuario si desea recuperar el archivo de intercambio (una copia automática realizada por vi). ¿Qué debe hacer el usuario para descartar el archivo de intercambio?
		Presione d cuando se lo solicite vi.

	-En una sesión de vim, una línea fue previamente copiada al registro l. ¿Qué combinación de teclas registraría una macro en el registro a para pegar la 
	 línea en el registro l inmediatamente antes de la línea actual?
		La combinación qa"lPq, que significa q (“iniciar grabación de macro”), a (“asignar registro a a macro”), "l (“seleccionar texto en registro l”), P (“pegar antes de la línea actual”) y q (“finalizar grabación macro”).
