==========================================================
103.1 Trabajando en la línea de comandos
==========================================================
->Leccion 1 

EJERCICIOS GUIADOS 
	-Utilice el sistema man para determinar cómo decirle a apropos que envíe un comando breve para que solo envíe un mensaje corto de uso y luego salga.
	Ejecute man apropos y desplácese hacia abajo por la sección “Options” hasta llegar al párrafo --usage.

	-Utilice el sistema man para determinar qué licencia de copyright se asigna al comando grep.
	Ejecute man grep y desplácese hacia abajo a la sección “Copyright” del documento. Tenga en cuenta que el programa utiliza los derechos de autor de la Free Software Foundation


EJERCICIOS EXPLORATORIOS 
	-Identifique la arquitectura de hardware y la versión del kernel de Linux que se utiliza en su computadora en un formato de salida fácil de interpretar.
	Usamos uname -iv 

	-Imprima las últimas veinte líneas de la base de datos dinámica history y el archivo .bash_history para compararlos.
	podemos usar tail, cat bash_history | tail -n 20, son muy diferentes los arhcivos,

	-Utilice la herramienta apropos para identificar la página man donde encontrará el comando que necesitará para mostrar el tamaño de un dispositivo de bloque físico conectado en 
	 bytes en lugar de megabytes o gigabytes.
	Una forma sería ejecutar apropos con la cadena block, leer los resultados, observar que lsblk enumera los dispositivos de bloque (y, por lo tanto, sería la herramienta más adecuada para nuestras necesidades), ejecutar man lsblk, desplácese por la sección “Description” y observe que -b mostrará el tamaño del dispositivo en bytes. Finalmente, ejecute lsblk -b para visualizar la salida.
	$ apropos block
	$ man lsblk
	$ lsblk -b

->Leccion 2
EJERCICIOS GUIADOS 
	-Use el comando export para agregar un nuevo directorio a su ruta (este no debe sobrevivir a un reinicio).
	podemos hacer un ejemplo con la variable PATH, agregando un nuevo directorio, la linea de ejecucion, se veria como: export PATH="$PATH:/new/dir", si quieres que sea permanente, debes de agregarla al archivo ~/.bashrc o ~/.bash_profile 

	-Use el comando unset para eliminar la variable PATH. Intente ejecutar un comando (como sudo cat /etc/shadow) usando sudo. ¿Que pasó? ¿Por qué? (Al salir de su shell, volverá a su estado original).
	Es como si desaparecieran los comandos, Por que la variable PATH contiene el directorio en donde debe de buscar los comandos y al eliminarla, dejan de "existir"

EJERCICIOS EXPLORATORIOS 
	-Busque en Internet para encontrar y explorar la lista completa de caracteres especiales.
	Lista de ejemplo: & ; | * ? " ' [ ] ( ) $ < > { } # / \ ! ~

	-Intente ejecutar comandos usando cadenas formadas por caracteres especiales y usando varios métodos para escaparlos. ¿Hay diferencias entre la forma en que se comportan esos métodos?
	Escapar usando caracteres " conservará los valores especiales del signo de dólar, una barra invertida y la barra invertida. Escapar usando un carácter ' hará que todos los caracteres sean literales.
	$ echo "$mynewvar"
	goodbye
	$ echo '$mynewvar'
	$mynewvar



==========================================================
103.2 Pricesosar secuecnias de texto usando fltros
==========================================================
EJERCICIOS  GUIADOS
	-Alguien acaba de donar una computadora portátil a su escuela y ahora desea instalar Linux en ella. No hay manual y se vio obligado a arrancarlo desde una unidad de memoria USB sin gráficos en absoluto. Obtiene acceso a un terminal de shell y se conoce, para cada procesador que tenga, habrá una línea para él en el archivo /proc/cpuinfo:
	processor	: 0
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158
	
	(líneas saltadas)

	processor	: 1
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158

	(se saltaron más líneas)
	Usando los comandos grep y wc muestre cuántos procesadores tiene.  --> grep "processor" /proc/cpuinfo | wc -l   o cat /proc/cpuinfo | grep processor | wc -l
	Haga lo mismo con sed en lugar de grep.  --> sed "/processor/p" < /proc/cpuinfo | wc -l 


	-Explore su archivo local /etc/passwd con los comandos grep, sed, head y tail según las siguientes tareas:
	¿Qué usuarios tienen acceso a un shell Bash?  --> cat /etc/passwd | grep "/bin/bash" | wc -l    o  sed -n "/\/bin\/bash/p" < /etc/passwd 
	Su sistema tiene varios usuarios que existen para manejar programas específicos o para fines administrativos. No tienen acceso a un shell. ¿Cuántos de esos existen en su sistema?  --> grep "nologin" $file | wc -l o sed -n "/nologin/p" $file | wc -l  oo  grep -v ":/bin/bash$" $file | wc -l
	¿Cuántos usuarios y grupos existen en su sistema (recuerde: use solo el archivo /etc/passwd)? --> cut -d ":" -f 3 $file | sort -un  | wc -l  y para los grupos seria cut -d ":" -f 4 $file | sort -un  | wc -l
	Muestre solo la primera línea, la última línea y la décima línea de su archivo /etc/passwd. head -n1  $file, tail -n1  $file, sed -n "10p" $file


	-Considere este ejemplo de archivo /etc/passwd. Copie las líneas siguientes en un archivo local llamado mypasswd para este ejercicio.
	root:x:0:0:root:/root:/bin/bash
	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
	bin:x:2:2:bin:/bin:/usr/sbin/nologin
	sys:x:3:3:sys:/dev:/usr/sbin/nologin
	sync:x:4:65534:sync:/bin:/bin/sync
	nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
	libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
	libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
	carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
	dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
	emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash

    Liste todos los usuarios en el grupo 1000 (use sed para seleccionar solo el campo apropiado) de su archivo mypasswd.
	sed -n "/1000:[A-Z]/p" passwd 

    Liste solo los nombres completos de todos los usuarios de este grupo (use sed y cut)
	sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5


EJERCICIOS EXPLORATORIOS
	-Una vez más, utilizando el archivo mypasswd de los ejercicios anteriores, idee un comando Bash que seleccionará a una persona de la Oficina Principal para ganar un concurso de rifas. 
	Use el comando sed para imprimir solo las líneas de la Oficina Principal, y luego una secuencia de comando cut para recuperar el nombre de cada usuario de estas líneas. A continuación, 
	deseará ordenar aleatoriamente estos nombres y solo imprimir el nombre superior de la lista.
		sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5 | sort -R 

	-¿Cuántas personas trabajan en Finanzas, Ingeniería y Ventas? (Considere explorar el comando uniq).
		 sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 | uniq -c 
	
	
	-Ahora desea preparar un archivo CSV (valores separados por comas) para poder importar fácilmente, desde el archivo mypasswd del ejemplo anterior, el archivo names.csv a LibreOffice. 
	El contenido del archivo tendrá el siguiente formato:
	First Name,Last Name,Position
	Carol,Smith,Finance
	...
	John,Chapel,Sales
	Consejo: Utilice los comandos sed, cut y paste para lograr los resultados deseados. Tenga en cuenta que la coma (,) será el delimitador de este archivo.
	Para este ejercicio, crearemos/ejecutaremos 4 passos, uno para nombres, otro para apellidos, otro para las posiciones y el ultimo lo juntaremos con el comando paste con la opcion -d que significa delimitador, entonces, nuestros pasos serian:
		1.- touch names && echo "Firs Name" > names && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 1 >> names
		2.- touch lnames && echo "Last Name" > lnames && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 2 >> lnames
		3.- touch position && echo "Position" > position  && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 >> position
		4.- paste -d "," names lnames position	> names.csv
		

	-Supongamos que la hoja de cálculo names.csv creada en el ejercicio anterior es un archivo importante y queremos asegurarnos de que nadie lo manipulará desde el momento en que se 
	 lo enviamos a alguien y el momento en que nuestro destinatario lo recibe. ¿Cómo podemos asegurar la integridad de este archivo usando md5sum?
		Lo podemos hacer con varios tipos de hash como md5sum, sh256sum, etc
			sha512sum names.csv 
			sha256sum names.csv 
			md5sum names.csv  --> 2c1b307d6535cd0943a01b87c855e181

	-Te prometiste a ti mismo que leerías un libro clásico de 100 líneas por día y decidiste comenzar con Mariner y Mystic de Herman Melville. 
	 Diseñe un comando usando split que separe este libro en secciones de 100 líneas cada una. Para obtener el libro en formato de texto plano, búsquelo en https://www.gutenberg.org.
		split -l 100 -d pg50461-images.html  parte


	-Usando ls -l en el directorio /etc, ¿qué tipo de listado obtiene? Usando el comando cut en la salida del comando ls dado, 
	 ¿cómo mostraría solo los nombres de archivo? ¿Qué pasa con el nombre del archivo y el propietario de los archivos? Junto con los comandos ls -l y cut, utilice el 
	 comando tr para suprimir las apariciones múltiples de un espacio en un solo espacio para ayudar a formatear la salida con un comando cut.
		Para mostrar solo los nombres de los arhcivos, podemos hacer lo siguiente
			ls -l | rev | cut -d " " -f 1 | rev
			o podemos usar el comando tr, como: ls -l | tr -s " " | cut -d " " -f 9
			Si necesitamos el nombre del archvios y el propietario necesitaremos las columnas 3 y 9  	
			como: ls -l | tr -s " " | cut -d " " -f9,3
			y si queremos el nombre de las carpetas y el propietario usaremos
			ls -l | grep ^d | tr -s " " | cut -d " " -f9,3
	
	
	-Este ejercicio asume que está en una máquina real (no en una máquina virtual). También debe tener una memoria USB con usted. 
	 Revise las páginas del manual para el comando tail y descubra cómo seguir un archivo a medida que se le agrega texto. 
	 Mientras monitorea la salida de un comando tail en el archivo /var/log/syslog, inserte una memoria USB. 
	 Escriba el comando completo que usaría para obtener el Producto, el Fabricante y la cantidad total de almacenamiento de su memoria USB.
		Podemos usar tail -f para monitorear registros o cualquier archivo que se actualice en tiempo real
		Sabiendo eso, podemos usar el comando sed para filtrar las opcioones que nos interesan, como el producto, el fabricante y la cantidad total de almacenamiento, el comando seria
			sed -n -e "/Product:/p" -e "/Manufacturer:/p" -e "/logical blocks:/p" /var/log/syslog
		o podemos usar el comando grep con la opcion -i que no distingue entre mayusculas o minusculas y ademas usaremos |, por lo que el comando seria
			tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
				\|: Este es el operador que actúa como un "O" lógico en expresiones regulares. Significa que se debe buscar cualquiera de los patrones conectados por él. En este caso, indica que también se buscará el siguiente patrón si no se encuentra el primero.


==========================================================
103.3 Gestion basica de archivos
==========================================================
->Leccion 1
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ ls -lh
	total 60K
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Desktop
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Documents
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Downloads
	-rw-r--r--  1   frank   frank     21    Sep 7   12:59   emp_name
	-rw-r--r--  1   frank   frank     20    Sep 7   13:03   emp_salary
	-rw-r--r--  1   frank   frank   8.8K    Apr 1   2018    examples.desktop
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file1
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file2
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Music
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Pictures
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Public
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Templates
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Videos

	    ¿Qué representa el caracter d en la salida? --> un directorio
	    ¿Por qué los tamaños se dan en formato legible para humanos? --> por que hemos usado la opcion -h del comando ls
	    ¿Cuál sería la diferencia en la salida si se usara ls sin argumentos? --> solo nos mostrar el contendio sin lo demas, como enlaces, nombre, grupo, etc
	
	-Considere el siguiente comando:
	$ cp /home/frank/emp_name /home/frank/backup
	    ¿Qué pasaría con el archivo emp_name si este comando se ejecuta con éxito? --> Copiaria el mismo contenido de emp_name a un nuevo archivo llamado backup
	    Si emp_name era un directorio, ¿qué opción debería agregarse a cp para ejecutar el comando?  --> -r, para que la accion sea recursiva
	    Si cp ahora se cambia a mv, ¿qué resultados espera? --> que solo se cambie de nombre, pero que tenga el mismo contenido (emp_name se movería a backup. Ya no estaría presente dentro del directorio de usuario frank.)
	
	-Considere el listado:
	$ ls
	file1.txt file2.txt file3.txt file4.txt
	¿Qué wildcard ayudaría a eliminar todo el contenido de este directorio? --> podriamos usar rm con el wildcard de * commo rm file*, pero eso es solo para estos archivos, si no queremos nada usamos rm *
	
	-Según el listado anterior, ¿qué archivos se mostrarían con el siguiente comando?
	$ ls file*.txt
		Todos los arhivos, ya que todos cumplen con el patron especificado, otra forma seria, ls file[1-4].txt
	
	-Complete el comando agregando los dígitos y caracteres apropiados entre corchetes que listarían todo el contenido anterior:
	$ ls file[].txt
	quedaria como ls file[0-9].txt -> NOTA:si tenemos archivks que superan el 9, podemos usar las llaves, como: ls file{1-13}.txt



EJERCICIO EXPLORATORIOS 
	-En su directorio de inicio, cree los archivos llamados dog y cat.
		touch dog cat
	
	-Aún en su directorio de inicio, cree el directorio llamado animal. Mueva dog y cat a animal.
		mkdir animal && mv dog cat animal	-> puede ocupar mv dog cat -t animal/, donde -t significa mover todos los arguentos fuente al directorio

	-Vaya a la carpeta Documents que se encuentra en su directorio de inicio y dentro, cree el directorio backup.
		cd Documents && mkdir backup	

	-Copie animal y su contenido en backup.
		cp -r ../animal/ backup/
	
	-Cambie el nombre de animal en backup a animal.bkup.
		mv animal animal.bkup	

	-El directorio /home/lpi/bases de datos contiene varios archivos incluyendo: db-1.tar.gz, db-2.tar.gz y db-3.tar.gz. ¿Qué comando único puede usar para listar solo los archivos mencionados anteriormente?
		ls -l db-[1-3]* o ls -l db-[1-3].tar.gz o ls -l db-{1..3}.tar.gz

	-Considere el listado:
	$ ls
	cne1222223.pdf cne12349.txt cne1234.pdf
	Con el uso de un solo carácter globbing, ¿qué comando eliminaría solo los archivos pdf?
		rm *.pdf


->Leccion 2
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ find /home/frank/Documents/ -type d
	/home/frank/Documents/
	/home/frank/Documents/animal
	/home/frank/Documents/animal/domestic
	/home/frank/Documents/animal/wild
	    ¿Qué tipo de archivos generaría este comando?  --> Directorios, ya que la opcion -type tiene d 
	    ¿En qué directorio comienza la búsqueda? --> En el directorio /hom/frank/Documents
	
	-Un usuario desea comprimir su carpeta de respaldo. Él usa el siguiente comando:
	$ tar cvf /home/frank/backup.tar.gz /home/frank/dir1
	¿Qué opción falta para comprimir la copia de seguridad utilizando el algoritmo gzip?
	Falta la opcion -z y ademas el guion inicial, el comando seria:
		tar-czvf /home/frank/backup.tar.gz /home/frank/dir1
	
	
EJERCICIO EXPLORATORIOS 
	-Como administrador del sistema, es necesario realizar verificaciones regulares para eliminar archivos voluminosos. Estos voluminosos archivos se encuentran en /var y terminan con una extensión .backup.
	    * Escriba el comando, usando find, para localizar estos archivos: -->	 find /var -name "*.backup"
	    *Un análisis de los tamaños de estos archivos revela que varían de 100M a 1000M. Complete el comando anterior con esta nueva información, para que pueda ubicar 
	     esos archivos de respaldo que van desde 100M a 1000M: -->		find /var -name "*.backup" -size +100M -size -1000M 
	    *Finalmente, complete este comando, con la acción de eliminación para que se eliminen estos archivos: -->		find /var -name "*.backup" -size +100M -size -1000M -exec rm {} \;
														  -->	      o find /var -name "*.backup" -size +100M -size -1000M -delete 
	
	-En el directorio /var, existen cuatro archivos de respaldo:
	db-jan-2018.backup
	db-feb-2018.backup
	db-march-2018.backup
	db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía un archivo con el nombre db-first-quarter-2018.backup.tar: 
			--> tar -cvf db-first-quarter-2018.backup.tar  db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía el archivo comprimido y comprímalo usando gzip. Tenga en cuenta que el nombre del archivo resultante debe terminar con .gz:
		        --> tar -czvf db-first-quarter-2018.backup.tar.gz db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup



==========================================================
103.4 Usar flujo, tuberias y redireccionamientos 
==========================================================
-Leccion 1 
EJERCICIOS GUIADOS	
	-Además de los archivos de texto, el comando cat también puede trabajar con datos binarios, como enviar el contenido de un dispositivo de bloque a un archivo. 
	 Usando la redirección, ¿cómo puede cat enviar el contenido del dispositivo /dev/sdc al archivo sdc.img en el directorio actual?
		cta /dev/sdc > sdc.img
	
	-¿Cuál es el nombre del canal estándar redirigido por el comando date 1> now.txt?
		 Salida estandar o  stdout 
	
	-Después de intentar sobrescribir un archivo usando la redirección, un usuario recibe un error informando que la opción noclobber está habilitada. 
	 ¿Cómo se puede desactivar la opción noclobber para la sesión actual?
		set +o noclobber 
	
	¿Cuál será el resultado del comando cat <<.>/dev/stdout?
		Asi como  es e lformato de Here document, como <<EOF y finaliza con un EOF, podemos sustituir este EOF por un punto (.), por lo que es lo mismo.
		Entonces con cat le pasaremos una entrada cualauqiera (ya conoces como inicia la linea de Here Docuemnt ">") que a su ves, redirigiremos lo que hemos escrito a stdout, osease la salida de la temrinal, por lo que cuando demos enter, veremos el mismo texto
	
	
EJERCICIOS EXPLORATORIOS 
	-El comando cat /proc/cpu_info muestra un mensaje de error porque /proc/cpu_info no existe. El comando cat /proc/cpu_info 2>1 redirige el mensaje de error a dónde?
		El comando cat /proc/cpu_info 2>1 intentaria redirigir la salida de error a un archivo llamado 1, lo cual no es lo que se pretende. La redireccion correcta para ver los mensajes de error en la terminal seria usando 2>&1, 
		si queremos redirigir tanto la salida estandar como la salida de erro, deberiamos de unar &> o &>>

	-¿Será posible descartar el contenido enviado a /dev/null si la opción noclobber está habilitada para la sesión de shell actual?
		Si, /dev/null es un archivo especial no afectado por noclobber	

	-Sin usar echo, ¿cómo se podría redirigir el contenido de la variable $USER al stdin del comando sha1sum?
		Podemos usar  HERE STRING, sha1sum <<< $USER

	-El kernel de Linux mantiene enlaces simbólicos en /proc/PID/fd/ a cada archivo abierto por un proceso, donde PID es el número de identificación del proceso correspondiente. 
	 ¿Cómo podría el administrador del sistema usar ese directorio para verificar la ubicación de los archivos de registro abiertos por nginx, suponiendo que su PID sea 1234?
		ls -l /proc/1234/fd, que mostrara los objetivos de cada enlace simbolico en el directorio

	
	-Es posible hacer cálculos aritméticos utilizando solo comandos integrados de shell, pero los cálculos de coma flotante requieren programas específicos, como bc (basic calculator). 
         Con bc incluso es posible especificar el número de lugares decimales, con el parámetro scale. Sin embargo, bc acepta operaciones solo a través de su entrada estándar, 
         generalmente ingresada en modo interactivo. Usando una cadena Here, ¿cómo puede la operación de coma flotante scale = 6; 1 / 3 enviarse a la entrada estándar de bc?
		Lo podemos hacer con cadena Here String, como bc <<< "scale=6; 1/3"
	
	
-Leccion 2
EJERCICIOS GUIADOS
	-Es conveniente guardar la fecha de ejecución de las acciones realizadas por scripts automatizados. El comando date +%Y-%m-%d muestra la fecha actual en formato año-mes-día. 
	 ¿Cómo se puede almacenar la salida de dicho comando en una variable de shell llamada TODAY usando la sustitución de comandos?
	
	-Usando el comando echo, ¿cómo se puede enviar el contenido de la variable TODAY a la entrada estándar del comando sed s/-/./g?
	
	-¿Cómo podría usarse la salida del comando date +%Y-%m-%d como una cadena Here para ordenar sed s/-/./g?
	
	-El comando convert image.jpeg -resize 25% small/image.jpeg crea una versión más pequeña de image.jpeg y coloca la imagen resultante en un archivo 
         con el mismo nombre dentro del subdirectorio small. Usando xargs, ¿cómo es posible ejecutar el mismo comando para cada imagen listada en el archivo filelist.txt?
	
	
EJERCICIOS EXPLORATORIOS 
	-Una rutina de copia de seguridad simple crea periódicamente una imagen de partición /dev/sda1 con dd < /dev/sda1 > sda1.img. 
	 Para realizar futuras comprobaciones de integridad de datos, la rutina también genera un hash SHA1 del archivo con 
	 sha1sum < sda1.img > sda1.sha1. Al agregar tuberías y el comando tee, ¿cómo se combinarían estos dos comandos en uno?
	
	-El comando tar se usa para archivar muchos archivos en uno solo, preservando la estructura del directorio. 
	 La opción -T permite especificar un archivo que contiene las rutas a archivar. 
	 Por ejemplo, find /etc -type f | tar -cJ -f /srv/backup/etc.tar.xz -T - crea un archivo tar comprimido etc.tar.xz de la lista provista por el 
	 comando find (la opción -T- indica la entrada estándar como la lista de ruta). 
	 Para evitar posibles errores de análisis debido a las rutas que contienen espacios, ¿qué opciones de comando deberían estar presentes para find y tar?
	
	-En lugar de abrir una nueva sesión de shell remota, el comando ssh solo puede ejecutar un comando indicado como argumento: ssh user@storage "remote command". 
	 Dado que ssh también permite redirigir la salida estándar de un programa local a la entrada estándar del programa remoto, 
	 ¿cómo canalizaría el comando cat un archivo local llamado etc.tar.gz a /srv/backup/etc.tar.gz en user@storage a través de ssh?
