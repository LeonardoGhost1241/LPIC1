==========================================================
103.1 Trabajando en la línea de comandos
==========================================================
->Leccion 1 

EJERCICIOS GUIADOS 
	-Utilice el sistema man para determinar cómo decirle a apropos que envíe un comando breve para que solo envíe un mensaje corto de uso y luego salga.
	Ejecute man apropos y desplácese hacia abajo por la sección “Options” hasta llegar al párrafo --usage.

	-Utilice el sistema man para determinar qué licencia de copyright se asigna al comando grep.
	Ejecute man grep y desplácese hacia abajo a la sección “Copyright” del documento. Tenga en cuenta que el programa utiliza los derechos de autor de la Free Software Foundation


EJERCICIOS EXPLORATORIOS 
	-Identifique la arquitectura de hardware y la versión del kernel de Linux que se utiliza en su computadora en un formato de salida fácil de interpretar.
	Usamos uname -iv 

	-Imprima las últimas veinte líneas de la base de datos dinámica history y el archivo .bash_history para compararlos.
	podemos usar tail, cat bash_history | tail -n 20, son muy diferentes los arhcivos,

	-Utilice la herramienta apropos para identificar la página man donde encontrará el comando que necesitará para mostrar el tamaño de un dispositivo de bloque físico conectado en 
	 bytes en lugar de megabytes o gigabytes.
	Una forma sería ejecutar apropos con la cadena block, leer los resultados, observar que lsblk enumera los dispositivos de bloque (y, por lo tanto, sería la herramienta más adecuada para nuestras necesidades), ejecutar man lsblk, desplácese por la sección “Description” y observe que -b mostrará el tamaño del dispositivo en bytes. Finalmente, ejecute lsblk -b para visualizar la salida.
	$ apropos block
	$ man lsblk
	$ lsblk -b

->Leccion 2
EJERCICIOS GUIADOS 
	-Use el comando export para agregar un nuevo directorio a su ruta (este no debe sobrevivir a un reinicio).
	podemos hacer un ejemplo con la variable PATH, agregando un nuevo directorio, la linea de ejecucion, se veria como: export PATH="$PATH:/new/dir", si quieres que sea permanente, debes de agregarla al archivo ~/.bashrc o ~/.bash_profile 

	-Use el comando unset para eliminar la variable PATH. Intente ejecutar un comando (como sudo cat /etc/shadow) usando sudo. ¿Que pasó? ¿Por qué? (Al salir de su shell, volverá a su estado original).
	Es como si desaparecieran los comandos, Por que la variable PATH contiene el directorio en donde debe de buscar los comandos y al eliminarla, dejan de "existir"

EJERCICIOS EXPLORATORIOS 
	-Busque en Internet para encontrar y explorar la lista completa de caracteres especiales.
	Lista de ejemplo: & ; | * ? " ' [ ] ( ) $ < > { } # / \ ! ~

	-Intente ejecutar comandos usando cadenas formadas por caracteres especiales y usando varios métodos para escaparlos. ¿Hay diferencias entre la forma en que se comportan esos métodos?
	Escapar usando caracteres " conservará los valores especiales del signo de dólar, una barra invertida y la barra invertida. Escapar usando un carácter ' hará que todos los caracteres sean literales.
	$ echo "$mynewvar"
	goodbye
	$ echo '$mynewvar'
	$mynewvar



==========================================================
103.2 Pricesosar secuecnias de texto usando fltros
==========================================================
EJERCICIOS  GUIADOS
	-Alguien acaba de donar una computadora portátil a su escuela y ahora desea instalar Linux en ella. No hay manual y se vio obligado a arrancarlo desde una unidad de memoria USB sin gráficos en absoluto. Obtiene acceso a un terminal de shell y se conoce, para cada procesador que tenga, habrá una línea para él en el archivo /proc/cpuinfo:
	processor	: 0
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158
	
	(líneas saltadas)

	processor	: 1
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 158

	(se saltaron más líneas)
	Usando los comandos grep y wc muestre cuántos procesadores tiene.  --> grep "processor" /proc/cpuinfo | wc -l   o cat /proc/cpuinfo | grep processor | wc -l
	Haga lo mismo con sed en lugar de grep.  --> sed "/processor/p" < /proc/cpuinfo | wc -l 


	-Explore su archivo local /etc/passwd con los comandos grep, sed, head y tail según las siguientes tareas:
	¿Qué usuarios tienen acceso a un shell Bash?  --> cat /etc/passwd | grep "/bin/bash" | wc -l    o  sed -n "/\/bin\/bash/p" < /etc/passwd 
	Su sistema tiene varios usuarios que existen para manejar programas específicos o para fines administrativos. No tienen acceso a un shell. ¿Cuántos de esos existen en su sistema?  --> grep "nologin" $file | wc -l o sed -n "/nologin/p" $file | wc -l  oo  grep -v ":/bin/bash$" $file | wc -l
	¿Cuántos usuarios y grupos existen en su sistema (recuerde: use solo el archivo /etc/passwd)? --> cut -d ":" -f 3 $file | sort -un  | wc -l  y para los grupos seria cut -d ":" -f 4 $file | sort -un  | wc -l
	Muestre solo la primera línea, la última línea y la décima línea de su archivo /etc/passwd. head -n1  $file, tail -n1  $file, sed -n "10p" $file


	-Considere este ejemplo de archivo /etc/passwd. Copie las líneas siguientes en un archivo local llamado mypasswd para este ejercicio.
	root:x:0:0:root:/root:/bin/bash
	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
	bin:x:2:2:bin:/bin:/usr/sbin/nologin
	sys:x:3:3:sys:/dev:/usr/sbin/nologin
	sync:x:4:65534:sync:/bin:/bin/sync
	nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
	libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
	libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
	carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
	dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
	emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
	john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash

    Liste todos los usuarios en el grupo 1000 (use sed para seleccionar solo el campo apropiado) de su archivo mypasswd.
	sed -n "/1000:[A-Z]/p" passwd 

    Liste solo los nombres completos de todos los usuarios de este grupo (use sed y cut)
	sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5


EJERCICIOS EXPLORATORIOS
	-Una vez más, utilizando el archivo mypasswd de los ejercicios anteriores, idee un comando Bash que seleccionará a una persona de la Oficina Principal para ganar un concurso de rifas. 
	Use el comando sed para imprimir solo las líneas de la Oficina Principal, y luego una secuencia de comando cut para recuperar el nombre de cada usuario de estas líneas. A continuación, 
	deseará ordenar aleatoriamente estos nombres y solo imprimir el nombre superior de la lista.
		sed -n "/Main Office/p" passwd | cut -d "," -f 1 | cut -d ":" -f5 | sort -R 

	-¿Cuántas personas trabajan en Finanzas, Ingeniería y Ventas? (Considere explorar el comando uniq).
		 sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 | uniq -c 
	
	
	-Ahora desea preparar un archivo CSV (valores separados por comas) para poder importar fácilmente, desde el archivo mypasswd del ejemplo anterior, el archivo names.csv a LibreOffice. 
	El contenido del archivo tendrá el siguiente formato:
	First Name,Last Name,Position
	Carol,Smith,Finance
	...
	John,Chapel,Sales
	Consejo: Utilice los comandos sed, cut y paste para lograr los resultados deseados. Tenga en cuenta que la coma (,) será el delimitador de este archivo.
	Para este ejercicio, crearemos/ejecutaremos 4 passos, uno para nombres, otro para apellidos, otro para las posiciones y el ultimo lo juntaremos con el comando paste con la opcion -d que significa delimitador, entonces, nuestros pasos serian:
		1.- touch names && echo "Firs Name" > names && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 1 >> names
		2.- touch lnames && echo "Last Name" > lnames && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 1 | cut -d " " -f 2 >> lnames
		3.- touch position && echo "Position" > position  && sed -n "/Main Office/p" passwd | cut -d ":" -f 5 | cut -d "," -f 2 >> position
		4.- paste -d "," names lnames position	> names.csv
		

	-Supongamos que la hoja de cálculo names.csv creada en el ejercicio anterior es un archivo importante y queremos asegurarnos de que nadie lo manipulará desde el momento en que se 
	 lo enviamos a alguien y el momento en que nuestro destinatario lo recibe. ¿Cómo podemos asegurar la integridad de este archivo usando md5sum?
		Lo podemos hacer con varios tipos de hash como md5sum, sh256sum, etc
			sha512sum names.csv 
			sha256sum names.csv 
			md5sum names.csv  --> 2c1b307d6535cd0943a01b87c855e181

	-Te prometiste a ti mismo que leerías un libro clásico de 100 líneas por día y decidiste comenzar con Mariner y Mystic de Herman Melville. 
	 Diseñe un comando usando split que separe este libro en secciones de 100 líneas cada una. Para obtener el libro en formato de texto plano, búsquelo en https://www.gutenberg.org.
		split -l 100 -d pg50461-images.html  parte


	-Usando ls -l en el directorio /etc, ¿qué tipo de listado obtiene? Usando el comando cut en la salida del comando ls dado, 
	 ¿cómo mostraría solo los nombres de archivo? ¿Qué pasa con el nombre del archivo y el propietario de los archivos? Junto con los comandos ls -l y cut, utilice el 
	 comando tr para suprimir las apariciones múltiples de un espacio en un solo espacio para ayudar a formatear la salida con un comando cut.
		Para mostrar solo los nombres de los arhcivos, podemos hacer lo siguiente
			ls -l | rev | cut -d " " -f 1 | rev
			o podemos usar el comando tr, como: ls -l | tr -s " " | cut -d " " -f 9
			Si necesitamos el nombre del archvios y el propietario necesitaremos las columnas 3 y 9  	
			como: ls -l | tr -s " " | cut -d " " -f9,3
			y si queremos el nombre de las carpetas y el propietario usaremos
			ls -l | grep ^d | tr -s " " | cut -d " " -f9,3
	
	
	-Este ejercicio asume que está en una máquina real (no en una máquina virtual). También debe tener una memoria USB con usted. 
	 Revise las páginas del manual para el comando tail y descubra cómo seguir un archivo a medida que se le agrega texto. 
	 Mientras monitorea la salida de un comando tail en el archivo /var/log/syslog, inserte una memoria USB. 
	 Escriba el comando completo que usaría para obtener el Producto, el Fabricante y la cantidad total de almacenamiento de su memoria USB.
		Podemos usar tail -f para monitorear registros o cualquier archivo que se actualice en tiempo real
		Sabiendo eso, podemos usar el comando sed para filtrar las opcioones que nos interesan, como el producto, el fabricante y la cantidad total de almacenamiento, el comando seria
			sed -n -e "/Product:/p" -e "/Manufacturer:/p" -e "/logical blocks:/p" /var/log/syslog
		o podemos usar el comando grep con la opcion -i que no distingue entre mayusculas o minusculas y ademas usaremos |, por lo que el comando seria
			tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
				\|: Este es el operador que actúa como un "O" lógico en expresiones regulares. Significa que se debe buscar cualquiera de los patrones conectados por él. En este caso, indica que también se buscará el siguiente patrón si no se encuentra el primero.


==========================================================
103.3 Gestion basica de archivos
==========================================================
->Leccion 1
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ ls -lh
	total 60K
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Desktop
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Documents
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Downloads
	-rw-r--r--  1   frank   frank     21    Sep 7   12:59   emp_name
	-rw-r--r--  1   frank   frank     20    Sep 7   13:03   emp_salary
	-rw-r--r--  1   frank   frank   8.8K    Apr 1   2018    examples.desktop
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file1
	-rw-r--r--  1   frank   frank     10    Sep 1   2018    file2
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Music
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Pictures
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Public
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Templates
	drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Videos

	    ¿Qué representa el caracter d en la salida? --> un directorio
	    ¿Por qué los tamaños se dan en formato legible para humanos? --> por que hemos usado la opcion -h del comando ls
	    ¿Cuál sería la diferencia en la salida si se usara ls sin argumentos? --> solo nos mostrar el contendio sin lo demas, como enlaces, nombre, grupo, etc
	
	-Considere el siguiente comando:
	$ cp /home/frank/emp_name /home/frank/backup
	    ¿Qué pasaría con el archivo emp_name si este comando se ejecuta con éxito? --> Copiaria el mismo contenido de emp_name a un nuevo archivo llamado backup
	    Si emp_name era un directorio, ¿qué opción debería agregarse a cp para ejecutar el comando?  --> -r, para que la accion sea recursiva
	    Si cp ahora se cambia a mv, ¿qué resultados espera? --> que solo se cambie de nombre, pero que tenga el mismo contenido (emp_name se movería a backup. Ya no estaría presente dentro del directorio de usuario frank.)
	
	-Considere el listado:
	$ ls
	file1.txt file2.txt file3.txt file4.txt
	¿Qué wildcard ayudaría a eliminar todo el contenido de este directorio? --> podriamos usar rm con el wildcard de * commo rm file*, pero eso es solo para estos archivos, si no queremos nada usamos rm *
	
	-Según el listado anterior, ¿qué archivos se mostrarían con el siguiente comando?
	$ ls file*.txt
		Todos los arhivos, ya que todos cumplen con el patron especificado, otra forma seria, ls file[1-4].txt
	
	-Complete el comando agregando los dígitos y caracteres apropiados entre corchetes que listarían todo el contenido anterior:
	$ ls file[].txt
	quedaria como ls file[0-9].txt -> NOTA:si tenemos archivks que superan el 9, podemos usar las llaves, como: ls file{1-13}.txt



EJERCICIO EXPLORATORIOS 
	-En su directorio de inicio, cree los archivos llamados dog y cat.
		touch dog cat
	
	-Aún en su directorio de inicio, cree el directorio llamado animal. Mueva dog y cat a animal.
		mkdir animal && mv dog cat animal	-> puede ocupar mv dog cat -t animal/, donde -t significa mover todos los arguentos fuente al directorio

	-Vaya a la carpeta Documents que se encuentra en su directorio de inicio y dentro, cree el directorio backup.
		cd Documents && mkdir backup	

	-Copie animal y su contenido en backup.
		cp -r ../animal/ backup/
	
	-Cambie el nombre de animal en backup a animal.bkup.
		mv animal animal.bkup	

	-El directorio /home/lpi/bases de datos contiene varios archivos incluyendo: db-1.tar.gz, db-2.tar.gz y db-3.tar.gz. ¿Qué comando único puede usar para listar solo los archivos mencionados anteriormente?
		ls -l db-[1-3]* o ls -l db-[1-3].tar.gz o ls -l db-{1..3}.tar.gz

	-Considere el listado:
	$ ls
	cne1222223.pdf cne12349.txt cne1234.pdf
	Con el uso de un solo carácter globbing, ¿qué comando eliminaría solo los archivos pdf?
		rm *.pdf


->Leccion 2
EJERCICIOS GUIADOS
	-Considere la siguiente lista:
	$ find /home/frank/Documents/ -type d
	/home/frank/Documents/
	/home/frank/Documents/animal
	/home/frank/Documents/animal/domestic
	/home/frank/Documents/animal/wild
	    ¿Qué tipo de archivos generaría este comando?  --> Directorios, ya que la opcion -type tiene d 
	    ¿En qué directorio comienza la búsqueda? --> En el directorio /hom/frank/Documents
	
	-Un usuario desea comprimir su carpeta de respaldo. Él usa el siguiente comando:
	$ tar cvf /home/frank/backup.tar.gz /home/frank/dir1
	¿Qué opción falta para comprimir la copia de seguridad utilizando el algoritmo gzip?
	Falta la opcion -z y ademas el guion inicial, el comando seria:
		tar-czvf /home/frank/backup.tar.gz /home/frank/dir1
	
	
EJERCICIO EXPLORATORIOS 
	-Como administrador del sistema, es necesario realizar verificaciones regulares para eliminar archivos voluminosos. Estos voluminosos archivos se encuentran en /var y terminan con una extensión .backup.
	    * Escriba el comando, usando find, para localizar estos archivos: -->	 find /var -name "*.backup"
	    *Un análisis de los tamaños de estos archivos revela que varían de 100M a 1000M. Complete el comando anterior con esta nueva información, para que pueda ubicar 
	     esos archivos de respaldo que van desde 100M a 1000M: -->		find /var -name "*.backup" -size +100M -size -1000M 
	    *Finalmente, complete este comando, con la acción de eliminación para que se eliminen estos archivos: -->		find /var -name "*.backup" -size +100M -size -1000M -exec rm {} \;
														  -->	      o find /var -name "*.backup" -size +100M -size -1000M -delete 
	
	-En el directorio /var, existen cuatro archivos de respaldo:
	db-jan-2018.backup
	db-feb-2018.backup
	db-march-2018.backup
	db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía un archivo con el nombre db-first-quarter-2018.backup.tar: 
			--> tar -cvf db-first-quarter-2018.backup.tar  db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup
	    *Usando tar, especifique el comando que crearía el archivo comprimido y comprímalo usando gzip. Tenga en cuenta que el nombre del archivo resultante debe terminar con .gz:
		        --> tar -czvf db-first-quarter-2018.backup.tar.gz db-jan-2018.backup db-feb-2018.backup db-march-2018.backup db-apr-2018.backup



==========================================================
103.4 Usar flujo, tuberias y redireccionamientos 
==========================================================
-Leccion 1 
EJERCICIOS GUIADOS	
	-Además de los archivos de texto, el comando cat también puede trabajar con datos binarios, como enviar el contenido de un dispositivo de bloque a un archivo. 
	 Usando la redirección, ¿cómo puede cat enviar el contenido del dispositivo /dev/sdc al archivo sdc.img en el directorio actual?
		cta /dev/sdc > sdc.img
	
	-¿Cuál es el nombre del canal estándar redirigido por el comando date 1> now.txt?
		 Salida estandar o  stdout 
	
	-Después de intentar sobrescribir un archivo usando la redirección, un usuario recibe un error informando que la opción noclobber está habilitada. 
	 ¿Cómo se puede desactivar la opción noclobber para la sesión actual?
		set +o noclobber 
	
	¿Cuál será el resultado del comando cat <<.>/dev/stdout?
		Asi como  es e lformato de Here document, como <<EOF y finaliza con un EOF, podemos sustituir este EOF por un punto (.), por lo que es lo mismo.
		Entonces con cat le pasaremos una entrada cualauqiera (ya conoces como inicia la linea de Here Docuemnt ">") que a su ves, redirigiremos lo que hemos escrito a stdout, osease la salida de la temrinal, por lo que cuando demos enter, veremos el mismo texto
	
	
EJERCICIOS EXPLORATORIOS 
	-El comando cat /proc/cpu_info muestra un mensaje de error porque /proc/cpu_info no existe. El comando cat /proc/cpu_info 2>1 redirige el mensaje de error a dónde?
		El comando cat /proc/cpu_info 2>1 intentaria redirigir la salida de error a un archivo llamado 1, lo cual no es lo que se pretende. La redireccion correcta para ver los mensajes de error en la terminal seria usando 2>&1, 
		si queremos redirigir tanto la salida estandar como la salida de erro, deberiamos de unar &> o &>>

	-¿Será posible descartar el contenido enviado a /dev/null si la opción noclobber está habilitada para la sesión de shell actual?
		Si, /dev/null es un archivo especial no afectado por noclobber	

	-Sin usar echo, ¿cómo se podría redirigir el contenido de la variable $USER al stdin del comando sha1sum?
		Podemos usar  HERE STRING, sha1sum <<< $USER

	-El kernel de Linux mantiene enlaces simbólicos en /proc/PID/fd/ a cada archivo abierto por un proceso, donde PID es el número de identificación del proceso correspondiente. 
	 ¿Cómo podría el administrador del sistema usar ese directorio para verificar la ubicación de los archivos de registro abiertos por nginx, suponiendo que su PID sea 1234?
		ls -l /proc/1234/fd, que mostrara los objetivos de cada enlace simbolico en el directorio

	
	-Es posible hacer cálculos aritméticos utilizando solo comandos integrados de shell, pero los cálculos de coma flotante requieren programas específicos, como bc (basic calculator). 
         Con bc incluso es posible especificar el número de lugares decimales, con el parámetro scale. Sin embargo, bc acepta operaciones solo a través de su entrada estándar, 
         generalmente ingresada en modo interactivo. Usando una cadena Here, ¿cómo puede la operación de coma flotante scale = 6; 1 / 3 enviarse a la entrada estándar de bc?
		Lo podemos hacer con cadena Here String, como bc <<< "scale=6; 1/3"
	
	
-Leccion 2
EJERCICIOS GUIADOS
	-Es conveniente guardar la fecha de ejecución de las acciones realizadas por scripts automatizados. El comando date +%Y-%m-%d muestra la fecha actual en formato año-mes-día. 
	 ¿Cómo se puede almacenar la salida de dicho comando en una variable de shell llamada TODAY usando la sustitución de comandos?
		TODAY=$(date +%Y-%m-%d)
		echo $TODAY
	
	-Usando el comando echo, ¿cómo se puede enviar el contenido de la variable TODAY a la entrada estándar del comando sed s/-/./g?
	echo $TODAY | date sed s/-/./g 
	
	-¿Cómo podría usarse la salida del comando date +%Y-%m-%d como una cadena Here para ordenar sed s/-/./g?
		sed s/-/./g <<< `date +%Y-%m-%d`	
		o
		sed s/-/./g <<< $(date +%Y-%m-%d)

	-El comando convert image.jpeg -resize 25% small/image.jpeg crea una versión más pequeña de image.jpeg y coloca la imagen resultante en un archivo 
         con el mismo nombre dentro del subdirectorio small. Usando xargs, ¿cómo es posible ejecutar el mismo comando para cada imagen listada en el archivo filelist.txt?
	 		El comando convert es parte de la suite de herramientas de ImageMagick, que se utiliza para la manipulacion de imagenes. Este comando permite convertir, redimensionar y realizar diversas operaciones en imagenes en varios formatos, como
			las opciones mas comunes son:
				-resize 50%	o -resize 1920x1080
				-format 
		cat filelist.txt | xargs -I image convert image -resize 50% small/image
		o
		xargs -I image convert image -resize 25% small/image < filelist.txt

	


EJERCICIOS EXPLORATORIOS 
	-Una rutina de copia de seguridad simple crea periódicamente una imagen de partición /dev/sda1 con dd < /dev/sda1 > sda1.img. 
	 Para realizar futuras comprobaciones de integridad de datos, la rutina también genera un hash SHA1 del archivo con 
	 sha1sum < sda1.img > sda1.sha1. Al agregar tuberías y el comando tee, ¿cómo se combinarían estos dos comandos en uno?
		sha1sum sda1.img | tee sda1.sha1	



	-El comando tar se usa para archivar muchos archivos en uno solo, preservando la estructura del directorio. 
	 La opción -T permite especificar un archivo que contiene las rutas a archivar. 
	 Por ejemplo, find /etc -type f | tar -cJ -f /srv/backup/etc.tar.xz -T - crea un archivo tar comprimido etc.tar.xz de la lista provista por el 
	 comando find (la opción -T- indica la entrada estándar como la lista de ruta). 
	 Para evitar posibles errores de análisis debido a las rutas que contienen espacios, ¿qué opciones de comando deberían estar presentes para find y tar?
	las opciones -print0 y --null
		find /etc -type f -print0 | tar -cJ -f /srv/backup/etc.tar.xz --null -T -

	
	-En lugar de abrir una nueva sesión de shell remota, el comando ssh solo puede ejecutar un comando indicado como argumento: ssh user@storage "remote command". 
	 Dado que ssh también permite redirigir la salida estándar de un programa local a la entrada estándar del programa remoto, 
	 ¿cómo canalizaría el comando cat un archivo local llamado etc.tar.gz a /srv/backup/etc.tar.gz en user@storage a través de ssh?
		$ cat etc.tar.gz | ssh user@storage "cat > /srv/backup/etc.tar.gz"
		o
		$ ssh user@storage "cat > /srv/backup/etc.tar.gz" < etc.tar.gz



==========================================================
103.5 Crear, supervisar y matar procesos 
==========================================================
->Leccion 1

EJERCICIOS GUIADOS
	-oneko es un programa divertido y agradable que muestra un gato persiguiendo el cursor del mouse. Si aún no está instalado en su sistema de escritorio, 
	 instálelo utilizando el administrador de paquetes de su distribución. Lo usaremos para estudiar el control del trabajo.
	    Inicia el programa. ¿Cómo lo hace?
			oneko
	    Mueva el cursor del mouse para ver cómo lo persigue el gato. Ahora suspenda el proceso. ¿Cómo hace eso? ¿Cuál es el resultado?
			Lo ponemos hacer con el shortcut Ctrl + Z

	    Compruebe cuántos trabajos tiene actualmente. ¿Qué escribe? ¿Cuál es el resultado?
			jobs -l	

	    Ahora envíelo al segundo plano especificando su ID de trabajo. ¿Cuál es el resultado? ¿Cómo puede saber que el trabajo se está ejecutando en segundo plano?
			bg %%, como el esl unico, podmeos usar %% o %+, de otro modo debemos especificar %n, ejem: bg %1

	    Finalmente, finalice el trabajo especificando su ID de trabajo. ¿Qué escribes?
			kill %% o kill %1
	

	-Descubra los PID de todos los procesos generados por Apache HTTPD web server (apache2) con dos comandos diferentes:
		Podemos usar pgrep y ps aux | grep "apache*", la ejecucion de estos seria:
			pgrep apache2 o pidof apache2
			ps aux | grep "apache"

	-Termine todos los procesos apache2 sin usar sus PID y con dos comandos diferentes:
		Podemos usar killall o pkill
			killall apache2
			kill $(pgrep apache2)
			pkill apache2
	

	-Suponga que tiene que terminar todas las instancias de apache2 y no tiene tiempo para averiguar cuáles son sus PID. ¿Cómo lograría eso usando kill con la señal predeterminada SIGTERM en una línea:
		kill -s SIGTERM $(pgrep apache2), por defecto kill usa la señal predeterminada de 15 o SIGTERM, por lo que no es necesario utilizarlo, por lo tanto, kill $(pidof apache2)


	-Inicie top e interactúe con él realizando lo siguiente:
	    Mostrar una vista del bosque de pocesos: se usa la opcion V, nos mostrara los procesos en forma de arbol	
	    Muestra rutas completas de procesos que diferencian entre espacio de usuario y espacio de kernel: Se puede usar la opcion c, para mostrar las  rutas de cada comando
	
	-Escriba el comando ps para mostrar todos los procesos iniciados por Apache HTTPD web server usuario (www-data):
	    Usando la sintaxis BSD: ps U www-data
	    Usando la sintaxis UNIX: ps -u www-data
	    Usando la sintaxis de GNU: ps --user www-data



EJERCICIOS EXPLORATORIOS

	-La señal SIGHUP puede usarse como una forma de reiniciar ciertos demonios. Con Apache HTTPD web server, por ejemplo, enviar SIGHUP al proceso padre (el que comenzó con init) mata a sus hijos. 
	 Sin embargo, el padre vuelve a leer sus archivos de configuración, vuelve a abrir los archivos de registro y genera un nuevo conjunto de hijos. Realice las siguientes tareas:
	    Inicie el servidor web:  sudo systemct start apache2
	    Asegúrese de conocer el PID del proceso principal: ps aux | grep apche2
	    Haga que el servidor web Apache HTTPD se reinicie enviándole la señal SIGHUP al proceso principal:kill -s SIGHUP 
	    Verifique que el padre no haya sido terminado y que se hayan generado nuevos hijos: el proceso incial lo inicio el root, por lo que podemos usar:
												kill -1 4094
												kill -SIGHUP 4094
												kill -s SIGHUP 4094


	-Aunque inicialmente estático, la salida de ps puede volverse dinámica combinando ps y watch. Supervisaremos Apache HTTPD web server para detectar nuevas conexiones. 
	 Antes de realizar las tareas descritas a continuación, se recomienda que lea la descripción de la directiva MaxConnectionsPerChild en Apache MPM Common Directives.	
	    Agregue la directiva MaxConnectionsPerChild con un valor de 1 en el archivo de configuración de apache2 — en Debian y derivados se encuentran en /etc/apache2/apache2.conf; 
	    en la familia CentOS, en /etc/httpd/conf/httpd.conf. No olvide reiniciar apache2 para que los cambios surtan efecto.
		La línea a incluir en el archivo de configuración es MaxConnectionsPerChild 1. Una forma de reiniciar el servidor web es a través de sudo systemctl restart apache2.

	    Escriba un comando que use watch, ps y grep para las conexiones apache2.
		watch 'ps aux | grep apache2' o watch "ps aux | grep apache2"
	
	    Ahora abra un navegador web o use un navegador de línea de comandos como lynx para establecer una conexión con el servidor web a través de su dirección IP. ¿Qué observa en la salida de watch?
		Uno de los procesos secundarios propiedad de www-data desaparece.

	
	-Como has aprendido, por defecto, top clasifica las tareas por porcentaje de uso de CPU en orden descendente (los valores más altos en la parte superior). 
	 Este comportamiento se puede modificar con las teclas interactivas M (uso de memoria), N (identificador único del proceso), T (tiempo de ejecución) y P (porcentaje del tiempo de CPU). 
	 Sin embargo, también puede ordenar la lista de tareas a su gusto iniciando top con la opción -o (para obtener más información, consulte la página man de top). Ahora, realice las siguientes tareas:
	
	    Inicie top para que las tareas se ordenen por uso de memoria: se usa top -o %MEM
	    Verifique que envió el comando correcto resaltando la columna de memoria: se usa la opcion x
	

	-ps también tiene una opción "o" para especificar las columnas que desea que se muestren. Investigue esta opción y realice las siguientes tareas:
		(https://man7.org/linux/man-pages/man1/ps.1.html#STANDARD_FORMAT_SPECIFIERS)
	    Inicie ps para que solo se muestre información sobre usuario, porcentaje de memoria utilizada, porcentaje de tiempo de CPU utilizado y comando completo: ps -o user,%mem,%cpu,cmd
	    Ahora, ejecute ps para que la única información que se muestre sea la del usuario y el nombre de los programas que están utilizando: ps o user,comm


->leccion 2
EJERCICIOS GUIADOS

	-Indique si las siguientes declaraciones/características corresponden a la GNU Screen, tmux o ambos:
	Característica/Declaración					GNU Screen					tmux
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	El prefijo de comando predeterminado es Ctrl+a			    *
	Modelo cliente-servidor												 *
	Los paneles son pseudo-terminales				    *
	Matar una región no mata sus ventanas asociadas
	Las sesiones incluyen ventanas
	Las sesiones se pueden separar					    *
			
	
	
	-Instale GNU Screen en su computadora (nombre del paquete: screen) y complete las siguientes tareas:	
	    Inicie el programa. ¿Qué comando utiliza?
	
	    Inicie top:
	
	    Usando el prefijo de la tecla de pantalla, abra una nueva ventana; luego, abra /etc/screenrc usando vi:
	
	    Liste las ventanas en la parte inferior de la pantalla:
	
	    Cambie el nombre de la ventana actual a vi:
	
	    Cambie el nombre de la ventana restante a top. Para hacer eso, primero muestre una lista de todas las ventanas para que pueda moverse hacia arriba y hacia abajo y seleccionar la correcta:
	
	    Verifique que los nombres hayan cambiado volviendo a mostrar los nombres de las ventanas en la parte inferior de la pantalla:
	
	    Ahora, separe la sesión y haga que screen cree una nueva llamada ssh:
	
	    Desconecte también de ssh y haga que screen muestre la lista de sesiones:
	
	    Ahora, adjunte a la primera sesión usando su PID:
	
	    Debería estar de vuelta en la ventana que muestra top. Divida la ventana horizontalmente y muévase a la nueva región vacía:
	
	    Haga que screen enumere todas las ventanas y seleccione vi para que se muestre en la nueva región vacía:
	
	    Ahora, divida la región actual verticalmente, muévase a la región vacía recién creada y asóciela con una nueva ventana:
	
	    Termine todas las regiones excepto la actual (recuerde, aunque mate las regiones, las ventanas siguen vivas). Luego, salga de todas las ventanas de la sesión actual hasta que termine la sesión:
	
	    Finalmente, haga que screen liste sus sesiones una vez más, elimine la sesión ssh restante por PID y verifique que en realidad no quedan sesiones:
	
	
	
	-Instale tmux en su computadora (nombre del paquete: tmux) y complete las siguientes tareas:
	
	    Inicie el programa. ¿Qué comando utiliza?
	
	    Inicie top (observe cómo, en un par de segundos, el nombre de la ventana cambia a top en la barra de estado):
	
	    Usando el prefijo de clave de tmux, abra una nueva ventana; luego, cree ~/.tmux.conf usando nano:
	
	    Divida la ventana verticalmente y reduzca el tamaño del panel recién creado varias veces:
	
	    Ahora cambie el nombre de la ventana actual a text editing; luego, haga que tmux muestre una lista con todas sus sesiones:
	
	    Vaya a la ventana que ejecuta top y vuelva a la actual usando la misma combinación de teclas:
	
	    Desconecte la sesión actual y cree una nueva cuyo nombre sea ssh y su nombre de ventana sea ssh window:
	
	    Desconecte también de la sesión ssh y haga que tmux muestre la lista de sesiones nuevamente:
	    Note:A partir de este punto, el ejercicio requiere que utilice una máquina remota para las conexiones ssh a su host local (una máquina virtual es perfectamente válida y puede resultar realmente práctica). Asegúrese de tener openssh-server instalado y ejecutándose en su máquina local y que al menos openssh-client esté instalado en la máquina remota.
	
	    Ahora, inicie una máquina remota y conéctese a través de ssh con su host local. Una vez que se haya establecido la conexión, verifique las sesiones tmux:
	
	    En el host remoto, adjunte a la sesión ssh por nombre:
	
	    De vuelta en su máquina local, conéctese a la sesión ssh por nombre, asegurándose de que la conexión al host remoto finalice primero:
	
	    Haga que todas las sesiones se muestren para su selección y vaya a su primera sesión ([0]). Una vez allí, mate la sesión ssh por su nombre:
	
	    Finalmente, desconéctese de la sesión actual y elimínela por su nombre:
	
	
	
	
	
	EJERCICIOS EXPLORATORIOS 
	
	-Tanto screen como tmux pueden ingresar al modo de línea de comandos a través de prefijo de comando + : (ya vimos un breve ejemplo con tmux). Investigue un poco y realice las siguientes tareas en el modo de línea de comandos:
	
	    Haga que screen entre en el modo de copia:
	
	    Haga que tmux cambie el nombre de la ventana actual:
	
	    Haga que screen cierre todas las ventanas y finalice la sesión:
	
	    Haga que tmux divida un panel en dos:
	
	    Haga que tmux elimine la ventana actual:
	
	
	-Cuando ingresa al modo de copia en screen, no solo puede usar las teclas de flecha y PgUP o PgDown para navegar por la ventana actual y el búfer de retroceso. También existe la posibilidad de utilizar un editor de pantalla completa similar a vi. Con este editor, realice las siguientes tareas:
	
	    Echo supercalifragilisticexpialidocious en su terminal screen:
	
	    Ahora, copie los cinco caracteres consecutivos (de izquierda a derecha) en la línea justo encima de su cursor:
	
	    Finalmente, pegue la selección (stice) en su símbolo del sistema:
	
	-Suponga que desea compartir una sesión tmux (our_session) con otro usuario. Ha creado el socket (/tmp/our_socket) con los permisos adecuados para que tanto usted como el otro usuario puedan leer y escribir. ¿Qué otras dos condiciones deben cumplirse para que el segundo usuario pueda adjuntar correctamente la sesión a través de tmux -S /tmp/our_socket a -t our_session?
