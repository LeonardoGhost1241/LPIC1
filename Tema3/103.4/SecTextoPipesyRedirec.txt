=============================================================
Leccion 1 - 103.4 Usar flujos, tuberías y redireccionamientos
=============================================================
Los procesos estandar de linux tienen 3 canales de comunicacion abiertos de manera prdeterminada
	1.- Canal de entrada (stdin), el descriptor numerico es 0 
	2.- Canal de salida (stout), el descriptor numerico es 1
	3.- Canal de error estandar (stderr), el descriptor numerico es 2 

Los canales de comunicacion tambien son accesibles a travez de los dispositivos especiales 
	1.- /dev/stin
	2.- /dev/stdout
	3.- /dev/stderr



Redireccionamientos
La reasignacion del descriptor de archivo de un canal en el entorno de shell se denomina redirect, una redireccion
se define con un carcater especial dentro de la linea de comando, 
Por ejemplo, para redirigir la salida estandar de un proceso a un archivo, se usa el sombolo ">"

ejemplo: cat /proc/cpuinfo > /tmp/cpu.txt
(por defecto, solo se redirige el contenido que llega a stdout)
bash redirige la salida estandar por defecto, por lo tanto, usar > es equivalente a usar 1> (el valor del descriptor del archvio stdout es 1)

Para capturar stderr, se debe usar la redireccion 2> en su lugar. La mayoria de los programas de linea de comando envian informacion de depuracion y mensajes de error al canal de error estandar.
Es posible leer el mensaje de error provocado por leer un archivo inexistente:
cat /proc/cpu_info 2> /tmp/error.txt


NOTA: Tanto STOUT como STDERR se redirigen al mismo objetivo con &> o <& (es importante nunca dejar espacion, de lo contrario, estariamos dejando el comando en segundo plano)

Para descartar la salida de unc omando, su contendio se puede redirigir al archivo especial /dev/null. en este archivo se puede escribir por cualquier usuario, pero no se puede recuperar datos, ya que no se almacenan en ningun lado


La redireccion de salida sobreescribe TODO un archivo cuando usamos solamente ">", sin embargo, 
para desactivarlo, desactivaremos una opcion de set, en este caso sera noclobber de set, para ello, haremos: set +o noclobber o simplemente set -C,
para volverlo a activar usaremos set +o noclobber o set +C 

Incluso con la opcion activada, podemos seguir redirigiendo string a un archvio, esto se hace con el doble ">>", ejem: echo "string" >> file.txt, eso no lo reescribira, sino que agregara una cadena 

El simbolo <, se usa para redirigir el contenido de una rchvio al stdin de un proceso. El comando uniq, como la mayoría de las utilidades de línea de comandos para procesar texto, acepta los datos enviados a stdin por defecto: uniw -c < /tmp/error.txt





HERE DOCUMENTO Y HERE STRING
Otra dorma de redirigir, involucra los dos metodos anteriores.
La redireccion de documentos Here permite escribir texto de varias lineas que se utilizaran como contenido redirigido.
Dos simbolos menor que << indian una redireccion de Here document 

un ejemplo seria: 
cat << EOF > file
> string...
> hola
> etc...
>EOF

eso redirigira la salida al archivo file

El metodo Here String es muy similar al mentodo de Here Document, pero solopara una linea:
ejem: wc -c <<< "How many characters in this Here String?"
Deben de estar entre comillas, de lo contrario, solo la primera palabra se usara como la cadena Here y las restantes se pasaran como argumentos al comando




=============================================================
Leccion 2 - 103.4 Usar flujos, tuberías y redireccionamientos
=============================================================
El caracter de barra vertical |, también conocido como el símbolo pipe, se puede usar para crear una tubería que conecte la salida de un programa directamente a la entrada de otro, mientras que command substitution permite almacenar la salida de un programa en una variable o usarlo directamente como argumento para otro comando.

Tuberias (Pipes) (|)
Este caracter le dice al shell que inicie todos los comandos distintos al mismo tiempo y que concatene la salida del comando anterior a la entrada del siguiente comando, de izquierda a derecha 
ejem: cat /proc/cpuinfo | wc 
ejem:  cat /proc/cpuinfo | grep 'model name' | uniq

Tambien se pueden combinar con redireccionamientos en la misma linea de comando, como:
grep 'model name' </proc/cpuinfo | uniq

Las tuberías y redirecciones son exclusivas, es decir, una fuente puede asignarse a un solo destino. Sin embargo, es posible redirigir una salida a un archivo y aún verlo en la pantalla con el programa tee. 
Para hacerlo, el primer programa envía su salida al stdin de tee y se le proporciona un nombre de archivo a este último para almacenar los datos

tee - lee la entrada de un comando y escribe la salida 
	-a usado para no sobreescribir el contenido del archivo proporcionado sino para agregarle datos

- - -- - - - - - - 
IMPORTANTE:
Solo la salida estándar de un proceso es capturada por una tubería. Digamos que debe pasar por un largo proceso de compilación en la pantalla y al mismo tiempo guardar tanto la 
salida estándar como el error estándar en un archivo para su posterior inspección. Suponiendo que su directorio actual no tiene un Makefile, el siguiente comando generará un error:

$ make | tee log.txt
make: *** No targets specified and no makefile found.  Stop.

Aunque se muestra en la pantalla, el mensaje de error generado por make no fue capturado por tee y el archivo log.txt se creó vacío. 
Se debe hacer una redirección antes de que una tubería pueda capturar el stderr:

$ make 2>&1 | tee log.txt
make: *** No targets specified and no makefile found.  Stop.
$ cat log.txt
make: *** No targets specified and no makefile found.  Stop.

En este ejemplo, el stderr de make se redirigió al stdout, por lo que tee pudo capturarlo con una tubería, mostrarlo en la pantalla y guardarlo en el archivo log.txt. 
En casos como este, puede ser útil guardar los mensajes de error para su posterior inspección.

- - - - - - - 


Sustitucion de comando
Este es otro metod para capturar la salida de un comando, colocar un comando dentro de las comillas inversas
ejem: mkdir 'date +%Y-%m-%d'

Se obtiene un resultado identico usando $() en lugar de commillas inversas
ejem:mkdir $(date +%Y-%m-%d)

se puede guardar una variable con la salida de un comando, como 
OS='uname -o'


Un método más sofisticado para usar la salida de un programa como argumento de otro programa emplea un intermediario llamado xargs

xargs - Usa el contenido que recibe a travez de stdin para ejecutar un comando dado con los contenidos como argumento. Se utiliza para manejar listas de archivos o argumentos que provienen de otros comandos
	-n N Especifica el numero de argumentos pasados al comando en cada invocacion
	-d delim Establece un delimitador diferente para separar los argumentos (no muy comun)
	-0 indica que la entrada esta separada por caracteres nulos. Utilizado comunmente con la opcion find -print0 (le dice a xargs que el caracter nulo debe usarse como separador)
	-I str permite especificar un marcador de posicion que sera remplazado por cada argumento, ejem find / -iname "*.txt" | xargs -I str ls -l str



	

