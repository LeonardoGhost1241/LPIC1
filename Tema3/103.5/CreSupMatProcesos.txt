=========================================
103.5 Crear, monitorear y matar procesos
=========================================

Control de trabajos 
Los trabajos son procesos que se han iniciado de FORMA ITERATIVA A TRAVEZ DE UN TERMINAL, 
enviados asegundo plano y aun no han finalizado la ejecucion

para conocer los trabajos activos (y su estado) en su sistema 
jobs - muestra los trabajos, y no muestra nda si no los hay
	-l mostrara la ID del proceso justo antes del comando
	-n Lista los procesos que han cambiado de estado desde la ultima notificacion (Running, Stopped, Terminated o Done)
	-p Lista los ID de procesos
	-r Lista solos los procesos en ejecucion 
	-s Lista solamente los procesos detenidos (o suspendidos)

nota: recuerde, un trabajo tiene un ID de trabajo y un ID de proceso PID


salida de jobs 
$ jobs
[1]+  Stopped                 sleep 60

Permítanos explicar el resultado:
[1]    Este número es el ID del trabajo y se puede utilizar, precedido por un símbolo de porcentaje (%), para cambiar el estado del trabajo mediante las utilidades fg, bg y kill (como se mostrará más adelante).
+      El signo más indica el trabajo actual predeterminado (es decir, el último suspendido o enviado al segundo plano). El trabajo anterior está marcado con un signo menos (-). Cualquier otro trabajo anterior no está marcado.
Stopped    Descripción del estado del trabajo.
sleep 60    El comando o trabajo en ejecución.







Especificaciones de trabajo
los comandos jobs, fg ,bg y kill necesitan una especificacion o jobspec para actuar sobre un trabajo
%n	trabajo cuyo numero de identificacion es n, ejem: jobs %1
%str	trabajo cuya linea comienza con str, ejem: jobs %str, ejem: jobs %ls
%?str	trabajo cuya linea de comando contiene str, ejem: jobs %?le

%+ %%	Trabajao actual (El ultimo que se inicio en segundo plano o suspendido del primer plano)
%- Trabajo anterior, antes del actual, ejem jobs %-


Estado del trabajo: suspension, primer plano y segundo plano
fg	llevar al primer plano y lo convierte en el trabajo actual (podemos detenerlo con ctrl + Z o  con ctrl + C)
bg	se puede usar el signo & al final del comando y asi lo pondremos en segundo plano
kill	se usa para terminar procesos iniciados desde la terminal, ejem kill %1
 


Trabajos separados
Si la sesion se termina, los trabajos desaparecen. Es posible separar los trabajos de las sesiones y hacer  que se ejcuten incluso despues de cerrar la sesion
esto se puede lograr con el comando nohub (no hangup)

sintaxis 
nohup command &

ejemplo: nohup ping 8.8.8.8 localhost &
la salida muestra el ID del trabajo y el ID del proceso, seguido de un mensaje que no sinforma sobre el archivo nohub.out
En este archivo se guardaran stdout y stderr

Si queremos matar el proces, debemos especificar su PID, como kill 1251



Monitoreo de procesos
watch - nos permite mirar el cambio de salida del programa con el tiempo, por ejemplo, watch  uptime, el comando se ejecuta hasta que se termina con ctrl + C
	-n o --interval  nos permite definir un intervalo de actualizacion, ejemplo watch -n 5 free (el comando se ejecutara cada 5 segundos)



Envio de señales a proceso: kill
Cada proceso tiene un identificador de proceso unico PID
Una forma de averiguar el PID de un proceso es con el comando pgrep

pgrep - permite averigua el PID de un proceso
	ejem, pgrep sleep 

otro comando que se puede utilizar es el comando pidof, ejem, pidof sleep

pkill - mata un proceso basado en su nombre
	ejem. pkill sleep

killall - mata varias INSTANCIAS del mismo proceso
	  ejem: killall sleep 
	 ejem: killall $(pgrep firefox)    donde mata varias instancias de firefox
	o simplemente kill $(pgrep firefox)  -> como se vio en anteriores lecciones, puedes especificar $() o '' para ejecutar comandos 


Por defecto, pkill y killall envian la señal pordefecto de SIGTERM
Sin embargo kill puede especificar varias señales de diversas formas, como:
	kill -SIGTERM 1234
	kill -1 1234
	kill -s SIGHUP 1234    donde s es signal     -> Para ver todas las señales disponibles usamos, kill -l 







TOP Y PS
TOP produce resultados dinamicamente
PS produce resultados esteticamente 


Interactuando con top
Este comadno nos muestra los procesos y mientras vemos como se ejcutan, podemos usar alguos "comandos" cuando se este ejecutando

M	Odena por uso de memoria.
N	Ordena por número de ID.
T	Ordena por tiempo de ejecución.
P	Ordena por porcentaje de uso en CPU.
R	Cambiar entre orden descendente/ascendente

otras teclas son:
? o h	Ayuda.
k	Mata un proceso. top solicitará que se elimine el PID del proceso y que se envíe la señal (por defecto, SIGTERM o 15).
r	Cambiar la prioridad de un proceso (renice). top le pedirá el valor nice. Los valores posibles oscilan entre -20 y 19, pero solo el superusuario (root) puede establecerlo en un valor negativo o inferior al actual.
u	Lista de procesos de un usuario en particular (de forma predeterminada se muestran los procesos de todos los usuarios).
c	Muestra las rutas absolutas de los programas y diferencia entre procesos de espacio de usuario y procesos de espacio de kernel (entre corchetes).
V	Vista de bosque/jerarquía de procesos.
t y m	Cambia el aspecto de las lecturas de CPU y memoria respectivamente en un ciclo de cuatro etapas: las dos primeras pulsaciones muestran barras de progreso, la tercera oculta la barra y la cuarta la recupera.
W	Guardar ajustes de configuración en ~/.toprc.






















	


