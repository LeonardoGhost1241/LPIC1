=========================================
103.5 Crear, monitorear y matar procesos
=========================================
-> Leccion 1
Control de trabajos 
Los trabajos son procesos que se han iniciado de FORMA ITERATIVA A TRAVEZ DE UN TERMINAL, 
enviados asegundo plano y aun no han finalizado la ejecucion

para conocer los trabajos activos (y su estado) en su sistema 
jobs - muestra los trabajos, y no muestra nda si no los hay
	-l mostrara la ID del proceso justo antes del comando
	-n Lista los procesos que han cambiado de estado desde la ultima notificacion (Running, Stopped, Terminated o Done)
	-p Lista los ID de procesos
	-r Lista solos los procesos en ejecucion 
	-s Lista solamente los procesos detenidos (o suspendidos)

nota: recuerde, un trabajo tiene un ID de trabajo y un ID de proceso PID


salida de jobs 
$ jobs
[1]+  Stopped                 sleep 60

Permítanos explicar el resultado:
[1]    Este número es el ID del trabajo y se puede utilizar, precedido por un símbolo de porcentaje (%), para cambiar el estado del trabajo mediante las utilidades fg, bg y kill (como se mostrará más adelante).
+      El signo más indica el trabajo actual predeterminado (es decir, el último suspendido o enviado al segundo plano). El trabajo anterior está marcado con un signo menos (-). Cualquier otro trabajo anterior no está marcado.
Stopped    Descripción del estado del trabajo.
sleep 60    El comando o trabajo en ejecución.







Especificaciones de trabajo
los comandos jobs, fg ,bg y kill necesitan una especificacion o jobspec para actuar sobre un trabajo
%n	trabajo cuyo numero de identificacion es n, ejem: jobs %1
%str	trabajo cuya linea comienza con str, ejem: jobs %str, ejem: jobs %ls
%?str	trabajo cuya linea de comando contiene str, ejem: jobs %?le

%+ %%	Trabajao actual (El ultimo que se inicio en segundo plano o suspendido del primer plano)
%- Trabajo anterior, antes del actual, ejem jobs %-


Estado del trabajo: suspension, primer plano y segundo plano
fg	llevar al primer plano y lo convierte en el trabajo actual (podemos detenerlo con ctrl + Z o  con ctrl + C)
bg	se puede usar el signo & al final del comando y asi lo pondremos en segundo plano
kill	se usa para terminar procesos iniciados desde la terminal, ejem kill %1
 


Trabajos separados
Si la sesion se termina, los trabajos desaparecen. Es posible separar los trabajos de las sesiones y hacer  que se ejcuten incluso despues de cerrar la sesion
esto se puede lograr con el comando nohub (no hangup)

sintaxis 
nohup command &

ejemplo: nohup ping 8.8.8.8 localhost &
la salida muestra el ID del trabajo y el ID del proceso, seguido de un mensaje que no sinforma sobre el archivo nohub.out
En este archivo se guardaran stdout y stderr

Si queremos matar el proces, debemos especificar su PID, como kill 1251



Monitoreo de procesos
watch - nos permite mirar el cambio de salida del programa con el tiempo, por ejemplo, watch  uptime, el comando se ejecuta hasta que se termina con ctrl + C
	-n o --interval  nos permite definir un intervalo de actualizacion, ejemplo watch -n 5 free (el comando se ejecutara cada 5 segundos)



Envio de señales a proceso: kill
Cada proceso tiene un identificador de proceso unico PID
Una forma de averiguar el PID de un proceso es con el comando pgrep

pgrep - permite averigua el PID de un proceso
	ejem, pgrep sleep 

otro comando que se puede utilizar es el comando pidof, ejem, pidof sleep

pkill - mata un proceso basado en su nombre
	ejem. pkill sleep

killall - mata varias INSTANCIAS del mismo proceso
	  ejem: killall sleep 
	 ejem: killall $(pgrep firefox)    donde mata varias instancias de firefox
	o simplemente kill $(pgrep firefox)  -> como se vio en anteriores lecciones, puedes especificar $() o '' para ejecutar comandos 


Por defecto, pkill y killall envian la señal pordefecto de SIGTERM
Sin embargo kill puede especificar varias señales de diversas formas, como:
	kill -SIGTERM 1234
	kill -1 1234
	kill -s SIGHUP 1234    donde s es signal     -> Para ver todas las señales disponibles usamos, kill -l 







TOP Y PS
TOP produce resultados dinamicamente
PS produce resultados esteticamente 


Interactuando con top
Este comadno nos muestra los procesos y mientras vemos como se ejcutan, podemos usar alguos "comandos" cuando se este ejecutando

M	Odena por uso de memoria.
N	Ordena por número de ID.
T	Ordena por tiempo de ejecución.
P	Ordena por porcentaje de uso en CPU.
R	Cambiar entre orden descendente/ascendente

otras teclas son:
? o h	Ayuda.
k	Mata un proceso. top solicitará que se elimine el PID del proceso y que se envíe la señal (por defecto, SIGTERM o 15).
r	Cambiar la prioridad de un proceso (renice). top le pedirá el valor nice. Los valores posibles oscilan entre -20 y 19, pero solo el superusuario (root) puede establecerlo en un valor negativo o inferior al actual.
u	Lista de procesos de un usuario en particular (de forma predeterminada se muestran los procesos de todos los usuarios).
c	Muestra las rutas absolutas de los programas y diferencia entre procesos de espacio de usuario y procesos de espacio de kernel (entre corchetes).
V	Vista de bosque/jerarquía de procesos.
t y m	Cambia el aspecto de las lecturas de CPU y memoria respectivamente en un ciclo de cuatro etapas: las dos primeras pulsaciones muestran barras de progreso, la tercera oculta la barra y la cuarta la recupera.
W	Guardar ajustes de configuración en ~/.toprc.


NOta:Para mas info de la interfaz y su significado, visitar (https://learning.lpi.org/es/learning-materials/101-500/103/103.5/103.5_01/)



INteractuando con ps
ps tiene 3 estilos diferentes para correrlo, BSD, UNIX y GNU.
BSD - Las opciones no siguen ningun guion inicial 
	ps p 811
UNIX - Las opciones siguen un guion inicial
	ps -p 811
GNU - Las opciones van seguidas de guiones dobles iniciales
	ps --pid 811

por lo que para buscar los procesos de un usuario, usaremos:
	ps U leonardo
	ps -u leonardo
	ps --user leonardo 


Salida del comando
$ ps U leonardo
   PID TTY      STAT   TIME COMMAND
   811 pts/0    S      0:00 -su
   898 pts/0    R+     0:00 ps U carol

La columna STAT nos dice el estado del proceso
a	muestra procesos que estan conectados a un tty o terminal
u	Muestra formato orientado al usuario
x	Mostrar procesos que no estan conectadis a yb tty o terminal





Permítanos explicar las columnas:

USER    Dueño del proceso.
PID    Identificador de proceso.
%CPU    Porcentaje de CPU utilizado.
%MEM    Porcentaje de memoria física utilizado.
VSZ    Memoria virtual de procesos en KiB.
RSS    Memoria física no intercambiada utilizada por el proceso en KiB.
TT    Terminal (tty) que controla el proceso.
STAT    Código que representa el estado del proceso. Además de S, R y Z (que vimos al describir la salida de top), otros valores posibles incluyen: D (suspensión ininterrumpida — generalmente esperando E/S), T (detenido — normalmente por una señal de control). Algunos modificadores adicionales incluyen: < (alta prioridad — no agradable para otros procesos), N (baja prioridad — agradable para otros procesos) o + (en el grupo de procesos en primer plano).
STARTED    Hora a la que comenzó el proceso.
TIME    Tiempo de CPU acumulado.
COMMAND    Comando que inició el proceso.





=========================================
103.5 Crear, monitorear y matar procesos
=========================================
->Leccion 2

Uso de multiplexores (screen y tmux), aunque no son los mismo, algunas caracteristicas de estos son:
	->Cualquier invocación exitosa dará como resultado al menos una sesión que, a su vez, incluirá al menos una ventana. Las ventanas contienen programas.
	->Las ventanas se puede dividir en regiones o paneles, lo que puede ayudar a la productividad cuando se trabaja con varios programas simultáneamente.
	->Facilidad de control: para ejecutar la mayoría de los comandos, utilizan una combinación de teclas, el llamado comando prefijo o comando clave, seguido de otro caracter.
	->Las sesiones se pueden separar de su terminal actual (es decir, los programas se envían en segundo plano y continúan ejecutándose). Esto garantiza la ejecución completa de los programas sin importar si cerramos accidentalmente un terminal, experimentamos un congelamiento ocasional del terminal o incluso una pérdida de conexión remota.
	->Conexiones de Socket.
	->Modo de copia.
	->Son altamente personalizables.


-------
SCREEN 
_______
screen - invoca una sesion 
	Prefijo Ctrl + a

Ventanas:
w - ver todas las ventanas en la parte inferior de la pantalla de la temrinal
c - crear una nueva ventana (el conteo inicia desde 0 en adelante, por lo que cuando iniciemos este multiplexor, iniciara con 0)
A - Cambiar el nombre de la ventana actual de screen
screen -t name	- podemos usar este comando dentro o fuera del multiplexor para iniciar una sesion con un nombre inicial
n - siguiente ventana
p - privious ventana Windows
numero - podemos cambiar de ventanas dado un numero, Ctrl + a - numero, ejem Ctrl + a - 2, nos cambiara a la tercera ventana
" - Podremos ver todas las sesiones en forma de lista y seleccionar alguna con las flechas del teclado

nota:
	-> Las ventanas ejecutan sus programas de forma completamente independiente entre si
	-> Los programas seguiran ejecutanmdose incluso si su ventana no esta visible (tambien cuando se desconecta la sesion de pantalla)

exit o k - para eliminar una ventana, podemos usar cualquiera de estas dos opciones, nos pedira confirmacion antes de llevar acabo la accion 


Regiones:
S - Para dividir la regio de forma horizontal
| - Para dividir de forma vertical
nota:cuando tengamos la region, podremos poner cualquier ventana existente dentro de ella, con la opcion "
Tab - Para moverse a una region 
Q - Termina todas las regiones excepto la actual
X - Terminar la region actual

Sesiones:
screen --list / screen -ls  - Listar todas las sesiones de screen

la salida de este comando sera:
$ screen -list
There is a screen on:
        1037.pts-0.debian       (08/24/19 13:53:35)     (Attached)
1 Socket in /run/screen/S-carol.

donde 
	PID
		1037
	Name
		pts-0.debian (indicando el trminal, en este caso pseudo terminal esclavo-el nombre del host)
	Status
		Attached
	
screen -S "name session"  -  Establece un nombre de una sesion 

screen -S session-PID -X quit  - Termina una sesion, la opcion -S se puede especificar el PID o el nombre como el anterior


Desvincular Sesiones:
Quiza desea
	->Conectarse desde su casa y seguir trabajando
	->Compartir una sesion con otro usuario

screen -d PID - Podemos desconectarnos de una sesion con d, ejem: ctrl + a - d, o desvincular una sesion en especifico con el PID, como screen -d 3324
screen -r PID  - Podemos volvernos a vinclar con el PID

Algunas otras opciones del comando screen

-d -r	Vuelva a conectar una sesión y, si es necesario, desconéctela primero.
-d -R	Igual que -d -r pero screen incluso creará la sesión primero si no existe.
-d -RR	Igual que -d -R. Sin embargo, utilice la primera sesión si hay más de una disponible.
-D -r	Vuelva a conectar una sesión. Si es necesario, desconecte y cierre la sesión de forma remota primero.
-D -R	Si se está ejecutando una sesión, vuelva a conectarla (desconecte y cierre la sesión de forma remota primero si es necesario). Si no se estaba ejecutando créelo y notifique al usuario.
-D -RR	Lo mismo que -D -R - solo que más fuerte.
-d -m	Inicie screen en modo independiente. Esto crea una nueva sesión pero no se vincula a ella. Esto es útil para los scripts de inicio del sistema.
-D -m	 Igual que -d -m, pero no bifurca un nuevo proceso. El comando sale si la sesión termina.



Copiar y pegar: modo Scrollback
GNU Screen presenta un modo de copia o scrollback. Una vez ingresado, puede mover el cursor en la ventana actual y 
por el contenido de su historial usando las teclas de flecha. Puede marcar texto y copiarlo en ventanas. Los pasos a seguir son:

    Ingrese al modo de copia/scrollback: Ctrl+a-[.

    Vaya al principio del texto que desea copiar usando las teclas de flecha.

    Marque el comienzo del fragmento de texto que desea copiar: Espacio.

    Vaya al final del fragmento de texto que desea copiar usando las teclas de flecha.

    Marque el final del fragmento de texto que desea copiar: Espacio.

    Vaya a la ventana de su elección y pegue el fragmento de texto: Ctrl+a-].



Personalizacion de screen 
El archivo de configuración de todo el sistema para screen es /etc/screenrc. Alternativamente, se puede usar un ~/.screenrc a nivel de usuario. 
El archivo incluye cuatro secciones principales de configuración:

SCREEN SETTINGS: Puede definir la configuración general especificando la directiva seguida de un espacio y el valor como en: defscrollback 1024.

SCREEN KEYBINDINGS:
	Esta sección es bastante interesante ya que le permite redefinir combinaciones de teclas que quizás interfieran con su uso diario del terminal. 
	Utilice la palabra clave bind seguida de un espacio, el carácter que se utilizará después del prefijo del comando, 
	otro espacio y el comando como en: bind l kill (esta configuración cambiará la forma predeterminada de matar una ventana a Ctrl+a-l).
	Para mostrar todos los enlaces de la pantalla, escriba Ctrl+a-? O consulte la página del manual.
    		Tip:Por supuesto, también puede cambiar el prefijo del comando. Por ejemplo, para ir de Ctrl+a a Ctrl+b, simplemente agregue esta línea: escape ^Bb.

TERMINAL SETTINGS: Esta sección incluye configuraciones relacionadas con el tamaño de la ventana de la terminal y los búferes, entre otros. 
	 	   Para habilitar el modo sin bloqueo para manejar mejor las conexiones ssh inestables, por ejemplo, se utiliza la siguiente configuración: defnonblock 5.
STARTUP SCREENS:Puede incluir comandos para que varios programas se ejecuten en el inicio de la pantalla; por ejemplo: screen -t top top (screen abrirá una ventana llamada top con top adentro).





-------
TMUX 
_______










	


